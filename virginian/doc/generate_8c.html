<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Virginian: src/sql/generate.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Virginian</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">src/sql/generate.c File Reference</div>  </div>
</div>
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="virginian_8h_source.html">virginian.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="node_8h_source.html">node.h</a>&quot;</code><br/>
</div>
<p><a href="generate_8c_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structabsop.html">absop</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstracted <a class="el" href="structvirg__op.html" title="Opcode, including arguments.">virg_op</a> structure with metadata used in code generation.  <a href="structabsop.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structreg.html">reg</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">connects a vm register to an expression  <a href="structreg.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>RUNOP</b>(op)</td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aede80c5c542d75a08306354f7f31f2bb"></a><!-- doxytag: member="generate.c::absop" ref="aede80c5c542d75a08306354f7f31f2bb" args="" -->
typedef struct <a class="el" href="structabsop.html">absop</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#aede80c5c542d75a08306354f7f31f2bb">absop</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstracted <a class="el" href="structvirg__op.html" title="Opcode, including arguments.">virg_op</a> structure with metadata used in code generation. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2de1d48751c7bda364596eca745d491"></a><!-- doxytag: member="generate.c::reg" ref="ab2de1d48751c7bda364596eca745d491" args="" -->
typedef struct <a class="el" href="structreg.html">reg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#ab2de1d48751c7bda364596eca745d491">reg</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">connects a vm register to an expression <br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#a6e542d5084b2385d498d3664e31aba0d">expr_equal</a> (<a class="el" href="structnode__expr.html">node_expr</a> *x1, <a class="el" href="structnode__expr.html">node_expr</a> *x2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aefe7d633da51e9bf7502c2e51a972b9d"></a><!-- doxytag: member="generate.c::expr_findreg" ref="aefe7d633da51e9bf7502c2e51a972b9d" args="(node_expr *x)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#aefe7d633da51e9bf7502c2e51a972b9d">expr_findreg</a> (<a class="el" href="structnode__expr.html">node_expr</a> *x)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">loops through registers to check if the passed expression is identical <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f902c7a6f7c3b528fbd7d74dc344de8"></a><!-- doxytag: member="generate.c::getreg" ref="a8f902c7a6f7c3b528fbd7d74dc344de8" args="()" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#a8f902c7a6f7c3b528fbd7d74dc344de8">getreg</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get first unassigned register and increment counter <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa40128d0c62090fdedecf8c7255b1be8"></a><!-- doxytag: member="generate.c::regindex" ref="aa40128d0c62090fdedecf8c7255b1be8" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#aa40128d0c62090fdedecf8c7255b1be8">regindex</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">assigns each registers index based on its position in register table <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structabsop.html">absop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#a23c98d5a7e655021e2243f1732dab39c">create_absop</a> (int op, int p1, int p2, int p3, <a class="el" href="structabsop.html">absop</a> *opptr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60e61c0947f825c1872236d5c8bb3957"></a><!-- doxytag: member="generate.c::append" ref="a60e61c0947f825c1872236d5c8bb3957" args="(absop **ops_list, absop *newop)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#a60e61c0947f825c1872236d5c8bb3957">append</a> (<a class="el" href="structabsop.html">absop</a> **ops_list, <a class="el" href="structabsop.html">absop</a> *newop)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">appends absop to a linked list of absops used to build the statement <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#a5472d0d25d12e5a67d8836dca9cb604d">select_columnpass_recurse</a> (<a class="el" href="structnode__expr.html">node_expr</a> *x, unsigned table_id)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Used in pass 0 to recurse through expression trees to resolve datatypes.  <a href="#a5472d0d25d12e5a67d8836dca9cb604d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#a89273c8e67d359289e6d55fb28c2d5d0">select_columnpass_condrecurse</a> (<a class="el" href="structnode__condition.html">node_condition</a> *x, unsigned table_id)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#a00cd55b38f9af2b9d72f76476779c3d5">select_columnpass</a> (<a class="el" href="structnode__select.html">node_select</a> *root)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d9799a8581edeb8907ba543001430be"></a><!-- doxytag: member="generate.c::expr_valint" ref="a0d9799a8581edeb8907ba543001430be" args="(node_expr *x)" -->
int&#160;</td><td class="memItemRight" valign="bottom"><b>expr_valint</b> (<a class="el" href="structnode__expr.html">node_expr</a> *x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6bcf8d7788d42dd6cf2a3ecd48e742c"></a><!-- doxytag: member="generate.c::expr_valfloat" ref="ab6bcf8d7788d42dd6cf2a3ecd48e742c" args="(node_expr *x)" -->
float&#160;</td><td class="memItemRight" valign="bottom"><b>expr_valfloat</b> (<a class="el" href="structnode__expr.html">node_expr</a> *x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#ac9899b68828759f5eae42dc00af80ad2">select_resolveopspass_recurse</a> (<a class="el" href="structnode__expr.html">node_expr</a> *x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#a39739b571f9e9997018fa974fdc7ecc2">select_resolveopspass_condrecurse</a> (<a class="el" href="structnode__condition.html">node_condition</a> *x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#a33ab7485e7a795df8225bd8defbfb5ef">select_resolveopspass</a> (<a class="el" href="structnode__select.html">node_select</a> *root)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#ab8eb77f77473dd11466aacb580a3e666">select_structurepass_expr</a> (<a class="el" href="structabsop.html">absop</a> *ops_list, <a class="el" href="structnode__expr.html">node_expr</a> *expr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structabsop.html">absop</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#a141d9a0b0b60fc33babd46c91f12828a">select_structurepass_condrecurse</a> (<a class="el" href="structnode__condition.html">node_condition</a> *x, <a class="el" href="structabsop.html">absop</a> *ops_list, <a class="el" href="structabsop.html">absop</a> *onsuccess, <a class="el" href="structabsop.html">absop</a> *onfailure, <a class="el" href="structabsop.html">absop</a> *newop)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#ab02866ad29709e513f58d61ce1b8de82">select_structurepass</a> (<a class="el" href="structnode__select.html">node_select</a> *root, <a class="el" href="structabsop.html">absop</a> **ops)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#ac42c04f0256cd2b6bbc82047e4940e52">select_opplacepass</a> (<a class="el" href="structabsop.html">absop</a> *aop)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#aeb76bd04e58b3b6f9852bff32bfcda38">select_registerpass</a> (<a class="el" href="structabsop.html">absop</a> *aop)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#a2c845e0018d8773884873c4f42bd53b6">select_outputpass</a> (<a class="el" href="structabsop.html">absop</a> *aop, <a class="el" href="structvirg__vm.html">virg_vm</a> *<a class="el" href="vm__gpu_8cu.html#a946d0d35b3bc20faef9b521a79e7e89a">vm</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#a303958079340768f839ccbb074ccaf6a">select_cleanuppass</a> (<a class="el" href="structabsop.html">absop</a> *aop)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#a90dce4f4c4ebd4d2f2a2bf5c2bbc45ed">virg_sql_genselect</a> (<a class="el" href="structnode__select.html">node_select</a> *root, <a class="el" href="structvirg__vm.html">virg_vm</a> *<a class="el" href="vm__gpu_8cu.html#a946d0d35b3bc20faef9b521a79e7e89a">vm</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#a2a8a0e487b18c48216cf4f0944bd2d6e">virg_sql_generate</a> (<a class="el" href="structvirg__node__root.html">virg_node_root</a> *root, <a class="el" href="structvirg__vm.html">virg_vm</a> *<a class="el" href="vm__gpu_8cu.html#a946d0d35b3bc20faef9b521a79e7e89a">vm</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate opcodes from parsed sql tree.  <a href="#a2a8a0e487b18c48216cf4f0944bd2d6e"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae79511fcd661301cd55823fdac5b5e51"></a><!-- doxytag: member="generate.c::reg_table" ref="ae79511fcd661301cd55823fdac5b5e51" args="[VIRG_REGS]" -->
<a class="el" href="structreg.html">reg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#ae79511fcd661301cd55823fdac5b5e51">reg_table</a> [VIRG_REGS]</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">table of vm registers <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a66cae64bfc2d94b22085d77d4213cf2c"></a><!-- doxytag: member="generate.c::regcounter" ref="a66cae64bfc2d94b22085d77d4213cf2c" args="" -->
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="generate_8c.html#a66cae64bfc2d94b22085d77d4213cf2c">regcounter</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">counter of currently used vm registers <br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h2><a class="anchor" id="Description"></a>
Description</h2>
<p>This file contains the code generator used to turn an AST into opcodes that are executed using the returned virtual machine. It is accessed throug the <a class="el" href="generate_8c.html#a2a8a0e487b18c48216cf4f0944bd2d6e" title="Generate opcodes from parsed sql tree.">virg_sql_generate()</a> function. Since this code encapsulates a lot of complexity not touched in any other part of the code its all thrown together and not documented as rigorously as other parts of the codebase. Currently only simple SELECT statements are supported.</p>
<p>The code generator has the following passes:</p>
<ul>
<li>Pass 0: Resolve datatypes of expressions.</li>
<li>Pass 1: Resolve cases where both sides of an operator in an expression is a constant value, simplify to a single constant expression.</li>
<li>Pass 2: Create the basic structure of the statement, adding opcodes to a list.</li>
<li>Pass 3: Assign indices to opcodes.</li>
<li>Pass 4: Resolve register indirection and jumps between opcodes.</li>
<li>Pass 5: Output final opcodes. </li>
</ul>

<p>Definition in file <a class="el" href="generate_8c_source.html">generate.c</a>.</p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a71b5e8acc668e2b5b26dd0f4a519ac55"></a><!-- doxytag: member="generate.c::RUNOP" ref="a71b5e8acc668e2b5b26dd0f4a519ac55" args="(op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RUNOP</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">op</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<b>Value:</b><div class="fragment"><pre class="fragment"><span class="keywordflow">switch</span>(op) {                            \
                <span class="keywordflow">case</span> <a class="code" href="node_8h.html#a80595e22f59903ad8ac7a5d4ba85e80f" title="possible expression oprators">NODE_OP_PLUS</a> : result = op1 + op2; <span class="keywordflow">break</span>;  \
                <span class="keywordflow">case</span> NODE_OP_MINUS : result = op1 - op2; <span class="keywordflow">break</span>; \
                <span class="keywordflow">case</span> NODE_OP_MUL : result = op1 * op2; <span class="keywordflow">break</span>;   \
                <span class="keywordflow">case</span> NODE_OP_DIV : result = op1 / op2; <span class="keywordflow">break</span>;   \
                <span class="keywordflow">default</span> : assert(0);                                                    \
        }
</pre></div>
<p>Definition at line <a class="el" href="generate_8c_source.html#l00283">283</a> of file <a class="el" href="generate_8c_source.html">generate.c</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a23c98d5a7e655021e2243f1732dab39c"></a><!-- doxytag: member="generate.c::create_absop" ref="a23c98d5a7e655021e2243f1732dab39c" args="(int op, int p1, int p2, int p3, absop *opptr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structabsop.html">absop</a>* create_absop </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structabsop.html">absop</a> *&#160;</td>
          <td class="paramname"><em>opptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Initializes an abstract operator object, assigning arguments and allowing a pointer to another op to be added. This pointer is resolved later on. </p>

<p>Definition at line <a class="el" href="generate_8c_source.html#l00116">116</a> of file <a class="el" href="generate_8c_source.html">generate.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <a class="code" href="structabsop.html" title="Abstracted virg_op structure with metadata used in code generation.">absop</a> *x = (<a class="code" href="structabsop.html" title="Abstracted virg_op structure with metadata used in code generation.">absop</a>*)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structabsop.html" title="Abstracted virg_op structure with metadata used in code generation.">absop</a>));
        
        x-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.op = op;
        x-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p1 = p1;
        x-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p2 = p2;
        x-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p3 = p3;
        x-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p4.i = 0;
        x-&gt;<a class="code" href="structabsop.html#a085d347b23bf1c3a46339594965715b8" title="pointer to another op used if this op can jump to another location">opptr</a> = opptr;
        x-&gt;<a class="code" href="structabsop.html#a5663e74c53509383553e69396dea84b3" title="next op in linked list of ops built during code generation">next</a> = NULL;

        <span class="keywordflow">return</span> x;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a6e542d5084b2385d498d3664e31aba0d"></a><!-- doxytag: member="generate.c::expr_equal" ref="a6e542d5084b2385d498d3664e31aba0d" args="(node_expr *x1, node_expr *x2)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int expr_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode__expr.html">node_expr</a> *&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnode__expr.html">node_expr</a> *&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Compares two expressions, recursing to sub-expressions if necessary, to determine if they are identical. This is used in register assignment to check if an expression has already been stored in a register. </p>

<p>Definition at line <a class="el" href="generate_8c_source.html#l00054">54</a> of file <a class="el" href="generate_8c_source.html">generate.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="keywordflow">if</span>(x1-&gt;<a class="code" href="structnode__expr.html#a5df61fe9e1d916ec0be94bf54eb98fd2" title="a constant, a column from a data record, or an operation">type</a> != x2-&gt;<a class="code" href="structnode__expr.html#a5df61fe9e1d916ec0be94bf54eb98fd2" title="a constant, a column from a data record, or an operation">type</a>)
                <span class="keywordflow">return</span> 0;

        <span class="keywordflow">switch</span>(x1-&gt;<a class="code" href="structnode__expr.html#a5df61fe9e1d916ec0be94bf54eb98fd2" title="a constant, a column from a data record, or an operation">type</a>) {
                <span class="keywordflow">case</span> <a class="code" href="node_8h.html#a7479e9c639bfd5e2f4f27aaa37e18b25" title="possible datatypes for an expression">NODE_EXPR_INT</a> :
                        <span class="keywordflow">return</span> x1-&gt;val.i == x2-&gt;val.i;

                <span class="keywordflow">case</span> NODE_EXPR_FLOAT :
                        <span class="keywordflow">return</span> x1-&gt;val.f == x2-&gt;val.f;

                <span class="keywordflow">case</span> NODE_EXPR_STRING :
                        <span class="keywordflow">return</span> strcmp(x1-&gt;val.s, x2-&gt;val.s) == 0;

                <span class="comment">// if both are columns, we compare the column id</span>
                <span class="keywordflow">case</span> NODE_EXPR_COLUMN :
                        <span class="keywordflow">return</span> (x1-&gt;<a class="code" href="structnode__expr.html#aa4c9608320b6252fdd471e25921da73c" title="if this expression is a column type, note whether that column is id">iskey</a> == x2-&gt;<a class="code" href="structnode__expr.html#aa4c9608320b6252fdd471e25921da73c" title="if this expression is a column type, note whether that column is id">iskey</a> &amp;&amp; x1-&gt;val.i == x2-&gt;val.i);

                <span class="comment">// if this is a math op we must compare the op and both sides</span>
                <span class="keywordflow">case</span> NODE_EXPR_OP :
                        <span class="keywordflow">return</span> x1-&gt;val.i == x2-&gt;val.i &amp;&amp;
                                <a class="code" href="generate_8c.html#a6e542d5084b2385d498d3664e31aba0d">expr_equal</a>(x1-&gt;<a class="code" href="structnode__expr.html#af714b3267b64e8ad19bd95699106d285" title="left hand side of operation">lhs</a>, x2-&gt;<a class="code" href="structnode__expr.html#af714b3267b64e8ad19bd95699106d285" title="left hand side of operation">lhs</a>) &amp;&amp;
                                <a class="code" href="generate_8c.html#a6e542d5084b2385d498d3664e31aba0d">expr_equal</a>(x1-&gt;<a class="code" href="structnode__expr.html#a7934fcd17d71d6e6090a10420c1876a5" title="right hand side of operation">rhs</a>, x2-&gt;<a class="code" href="structnode__expr.html#a7934fcd17d71d6e6090a10420c1876a5" title="right hand side of operation">rhs</a>);

                <span class="keywordflow">default</span> :
                        assert(0);
        }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a303958079340768f839ccbb074ccaf6a"></a><!-- doxytag: member="generate.c::select_cleanuppass" ref="a303958079340768f839ccbb074ccaf6a" args="(absop *aop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void select_cleanuppass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structabsop.html">absop</a> *&#160;</td>
          <td class="paramname"><em>aop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pass 6 Cleans up all the abstract ops we had in our linked list </p>

<p>Definition at line <a class="el" href="generate_8c_source.html#l00781">781</a> of file <a class="el" href="generate_8c_source.html">generate.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <a class="code" href="structabsop.html" title="Abstracted virg_op structure with metadata used in code generation.">absop</a> *temp;

        <span class="keywordflow">for</span>(; aop != NULL; aop = temp) {
                temp = aop-&gt;<a class="code" href="structabsop.html#a5663e74c53509383553e69396dea84b3" title="next op in linked list of ops built during code generation">next</a>;
                free(aop);
        }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a00cd55b38f9af2b9d72f76476779c3d5"></a><!-- doxytag: member="generate.c::select_columnpass" ref="a00cd55b38f9af2b9d72f76476779c3d5" args="(node_select *root)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int select_columnpass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode__select.html">node_select</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pass 0 This is used to resolve the datatypes of expressions, including columns. Doing this requires iterating through each result column and condition, and recursing through trees of expressions </p>

<p>Definition at line <a class="el" href="generate_8c_source.html#l00231">231</a> of file <a class="el" href="generate_8c_source.html">generate.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="comment">// must have at least output col</span>
        assert(root-&gt;<a class="code" href="structnode__select.html#a934ac3686e22ca296911742c42247bd0" title="list of result columns, of which there must be at least one">resultcols</a> != NULL);

        <span class="comment">// iterate through each result column</span>
        <a class="code" href="structnode__resultcol.html" title="Represents a result column used in a SELECT statement.">node_resultcol</a> *col = root-&gt;<a class="code" href="structnode__select.html#a934ac3686e22ca296911742c42247bd0" title="list of result columns, of which there must be at least one">resultcols</a>;
        <span class="keywordflow">for</span>(; col != NULL; col = col-&gt;<a class="code" href="structnode__resultcol.html#ab5b614617fffe4584c39f9c793085806" title="pointer to next resultcol in list">next</a>) {
                <a class="code" href="virginian_8h.html#a5199c848f6c06c5aabdc6546774d4f0d" title="print an error and return failure if the condition is true">VIRG_CHECK</a>(
                        <a class="code" href="generate_8c.html#a5472d0d25d12e5a67d8836dca9cb604d" title="Used in pass 0 to recurse through expression trees to resolve datatypes.">select_columnpass_recurse</a>(col-&gt;<a class="code" href="structnode__resultcol.html#a52252324055937d2729b964b2eb494e2" title="expression used as result value">expr</a>, root-&gt;<a class="code" href="structnode__select.html#ac85a4cfc3c8b11c4ef1619f2071a2572" title="id of table for select statement">table_id</a>) == <a class="code" href="virginian_8h.html#ac21dbbc06d2c74731554f359edd10702" title="used to return a function failure">VIRG_FAIL</a>,
                        <span class="stringliteral">&quot;select_columnpass() failure&quot;</span>);
        }

        <span class="comment">// recurse through condition tree</span>
        <span class="keywordflow">if</span>(root-&gt;<a class="code" href="structnode__select.html#a62057b9735cbf4f75e54fa9d1edc0ecf" title="list of conditions, can be null">conditions</a> != NULL)
                <a class="code" href="generate_8c.html#a89273c8e67d359289e6d55fb28c2d5d0">select_columnpass_condrecurse</a>(root-&gt;<a class="code" href="structnode__select.html#a62057b9735cbf4f75e54fa9d1edc0ecf" title="list of conditions, can be null">conditions</a>, root-&gt;<a class="code" href="structnode__select.html#ac85a4cfc3c8b11c4ef1619f2071a2572" title="id of table for select statement">table_id</a>);

        <span class="keywordflow">return</span> <a class="code" href="virginian_8h.html#ae39e133b80ee1958313531a94cb517d2" title="used to return a function success">VIRG_SUCCESS</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a89273c8e67d359289e6d55fb28c2d5d0"></a><!-- doxytag: member="generate.c::select_columnpass_condrecurse" ref="a89273c8e67d359289e6d55fb28c2d5d0" args="(node_condition *x, unsigned table_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void select_columnpass_condrecurse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode__condition.html">node_condition</a> *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>table_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This is used in pass 0 to recurse through a tree of condition nodes, calling another function for each expression found </p>

<p>Definition at line <a class="el" href="generate_8c_source.html#l00211">211</a> of file <a class="el" href="generate_8c_source.html">generate.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="comment">// call on left and right hand expressions</span>
        <a class="code" href="generate_8c.html#a5472d0d25d12e5a67d8836dca9cb604d" title="Used in pass 0 to recurse through expression trees to resolve datatypes.">select_columnpass_recurse</a>(x-&gt;<a class="code" href="structnode__condition.html#a4b8af68e68b36b1064209288246ae41f" title="left hand expression for comparison">lhs</a>, table_id);
        <a class="code" href="generate_8c.html#a5472d0d25d12e5a67d8836dca9cb604d" title="Used in pass 0 to recurse through expression trees to resolve datatypes.">select_columnpass_recurse</a>(x-&gt;<a class="code" href="structnode__condition.html#a4522137b9b21c53b944c5e29be476a72" title="right hand expression for comparison">rhs</a>, table_id);

        <span class="comment">// recurse through and condition</span>
        <span class="keywordflow">if</span>(x-&gt;<a class="code" href="structnode__condition.html#a0fc745ea6013a76abb5e72d84cd810fd" title="AND condition.">andcond</a> != NULL)
                <a class="code" href="generate_8c.html#a89273c8e67d359289e6d55fb28c2d5d0">select_columnpass_condrecurse</a>(x-&gt;<a class="code" href="structnode__condition.html#a0fc745ea6013a76abb5e72d84cd810fd" title="AND condition.">andcond</a>, table_id);

        <span class="comment">// recurse through or condition</span>
        <span class="keywordflow">if</span>(x-&gt;<a class="code" href="structnode__condition.html#ab8e4409734a8c903f43681364e8202f5" title="OR condition.">orcond</a> != NULL)
                <a class="code" href="generate_8c.html#a89273c8e67d359289e6d55fb28c2d5d0">select_columnpass_condrecurse</a>(x-&gt;<a class="code" href="structnode__condition.html#ab8e4409734a8c903f43681364e8202f5" title="OR condition.">orcond</a>, table_id);
}
</pre></div>
</div>
</div>
<a class="anchor" id="a5472d0d25d12e5a67d8836dca9cb604d"></a><!-- doxytag: member="generate.c::select_columnpass_recurse" ref="a5472d0d25d12e5a67d8836dca9cb604d" args="(node_expr *x, unsigned table_id)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int select_columnpass_recurse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode__expr.html">node_expr</a> *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>table_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Used in pass 0 to recurse through expression trees to resolve datatypes. </p>

<p><p>switch based on expression type </p>
</p>

<p>Definition at line <a class="el" href="generate_8c_source.html#l00147">147</a> of file <a class="el" href="generate_8c_source.html">generate.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="keywordtype">unsigned</span> u = 0;
<span class="comment"></span>
<span class="comment">        /// switch based on expression type</span>
<span class="comment"></span>        <span class="keywordflow">switch</span>(x-&gt;<a class="code" href="structnode__expr.html#a5df61fe9e1d916ec0be94bf54eb98fd2" title="a constant, a column from a data record, or an operation">type</a>) {
                <span class="comment">// if the expression is a column, we must look at the table metadata to</span>
                <span class="comment">// determine what type it is</span>
                <span class="keywordflow">case</span> NODE_EXPR_COLUMN :
                        x-&gt;<a class="code" href="structnode__expr.html#aa4c9608320b6252fdd471e25921da73c" title="if this expression is a column type, note whether that column is id">iskey</a> = (strcmp(x-&gt;val.s, <span class="stringliteral">&quot;id&quot;</span>) == 0);

                        <span class="comment">// get column id from table</span>
                        <span class="keywordflow">if</span>(!x-&gt;<a class="code" href="structnode__expr.html#aa4c9608320b6252fdd471e25921da73c" title="if this expression is a column type, note whether that column is id">iskey</a>) {
                                <a class="code" href="virginian_8h.html#a5199c848f6c06c5aabdc6546774d4f0d" title="print an error and return failure if the condition is true">VIRG_CHECK</a>(<a class="code" href="group__table.html#ga9232ad719d86ce12da634af477c0181d" title="Find the ID of a table column given its name.">virg_table_getcolumn</a>(<a class="code" href="node_8h.html#af0669702def616c7b54949c6335afe1a" title="virginian object visible to the parser">parse_virg</a>, table_id,
                                                x-&gt;val.s, &amp;u) == <a class="code" href="virginian_8h.html#ac21dbbc06d2c74731554f359edd10702" title="used to return a function failure">VIRG_FAIL</a>,
                                        <span class="stringliteral">&quot;select_columnpass_recurse() could not locate column&quot;</span>);
                        }

                        <span class="comment">// free table name now that we have its id</span>
                        free(x-&gt;val.s);
                        x-&gt;val.u = x-&gt;<a class="code" href="structnode__expr.html#aa4c9608320b6252fdd471e25921da73c" title="if this expression is a column type, note whether that column is id">iskey</a> ? 0 : u;

                        <span class="comment">// get datatype of column</span>
                        <a class="code" href="virginian_8h.html#a5edb977d9e195d5df43f1757f311292b" title="enumeration of all variable types used by the database">virg_t</a> type;
                        <span class="keywordflow">if</span>(x-&gt;<a class="code" href="structnode__expr.html#aa4c9608320b6252fdd471e25921da73c" title="if this expression is a column type, note whether that column is id">iskey</a>)
                                <a class="code" href="group__table.html#ga94b2fe975e966c73b9790562c9004e35" title="Find the type of a table&#39;s key.">virg_table_getkeytype</a>(<a class="code" href="node_8h.html#af0669702def616c7b54949c6335afe1a" title="virginian object visible to the parser">parse_virg</a>, table_id, &amp;type);
                        <span class="keywordflow">else</span>
                                <a class="code" href="group__table.html#ga04c8f0729122ef8406e1a6c918bc4da6" title="Find the type of a table column.">virg_table_getcolumntype</a>(<a class="code" href="node_8h.html#af0669702def616c7b54949c6335afe1a" title="virginian object visible to the parser">parse_virg</a>, table_id, u, &amp;type);

                        x-&gt;<a class="code" href="structnode__expr.html#a3ee9ddd1ceb400b586e6ee02412a131f" title="datatype derived from the constant type, column type, or operation type">datatype</a> = type;
                        <span class="keywordflow">break</span>;

                <span class="comment">// if this expression is an operation we must recurse down each side,</span>
                <span class="comment">// then set this node&#39;s datatype to the more general type</span>
                <span class="keywordflow">case</span> NODE_EXPR_OP :
                        <a class="code" href="virginian_8h.html#a5199c848f6c06c5aabdc6546774d4f0d" title="print an error and return failure if the condition is true">VIRG_CHECK</a>(<a class="code" href="generate_8c.html#a5472d0d25d12e5a67d8836dca9cb604d" title="Used in pass 0 to recurse through expression trees to resolve datatypes.">select_columnpass_recurse</a>(x-&gt;<a class="code" href="structnode__expr.html#af714b3267b64e8ad19bd95699106d285" title="left hand side of operation">lhs</a>, table_id) == <a class="code" href="virginian_8h.html#ac21dbbc06d2c74731554f359edd10702" title="used to return a function failure">VIRG_FAIL</a>,
                                <span class="stringliteral">&quot;select_columnpass_recurse() failure&quot;</span>);
                        <a class="code" href="virginian_8h.html#a5199c848f6c06c5aabdc6546774d4f0d" title="print an error and return failure if the condition is true">VIRG_CHECK</a>(<a class="code" href="generate_8c.html#a5472d0d25d12e5a67d8836dca9cb604d" title="Used in pass 0 to recurse through expression trees to resolve datatypes.">select_columnpass_recurse</a>(x-&gt;<a class="code" href="structnode__expr.html#a7934fcd17d71d6e6090a10420c1876a5" title="right hand side of operation">rhs</a>, table_id) == <a class="code" href="virginian_8h.html#ac21dbbc06d2c74731554f359edd10702" title="used to return a function failure">VIRG_FAIL</a>,
                                <span class="stringliteral">&quot;select_columnpass_recurse() failure&quot;</span>);

                        <span class="comment">// get the more general of the two datatypes</span>
                        x-&gt;<a class="code" href="structnode__expr.html#a3ee9ddd1ceb400b586e6ee02412a131f" title="datatype derived from the constant type, column type, or operation type">datatype</a> = virg_generalizetype(x-&gt;<a class="code" href="structnode__expr.html#af714b3267b64e8ad19bd95699106d285" title="left hand side of operation">lhs</a>-&gt;<a class="code" href="structnode__expr.html#a3ee9ddd1ceb400b586e6ee02412a131f" title="datatype derived from the constant type, column type, or operation type">datatype</a>,
                                x-&gt;<a class="code" href="structnode__expr.html#a7934fcd17d71d6e6090a10420c1876a5" title="right hand side of operation">rhs</a>-&gt;<a class="code" href="structnode__expr.html#a3ee9ddd1ceb400b586e6ee02412a131f" title="datatype derived from the constant type, column type, or operation type">datatype</a>);
                        <span class="keywordflow">break</span>;

                <span class="comment">// this expression is a constant int</span>
                <span class="keywordflow">case</span> <a class="code" href="node_8h.html#a7479e9c639bfd5e2f4f27aaa37e18b25" title="possible datatypes for an expression">NODE_EXPR_INT</a> :
                        x-&gt;<a class="code" href="structnode__expr.html#a3ee9ddd1ceb400b586e6ee02412a131f" title="datatype derived from the constant type, column type, or operation type">datatype</a> = VIRG_INT;
                        <span class="keywordflow">break</span>;

                <span class="comment">// this expression is a constant float</span>
                <span class="keywordflow">case</span> NODE_EXPR_FLOAT :
                        x-&gt;<a class="code" href="structnode__expr.html#a3ee9ddd1ceb400b586e6ee02412a131f" title="datatype derived from the constant type, column type, or operation type">datatype</a> = VIRG_FLOAT;
                        <span class="keywordflow">break</span>;

                <span class="keywordflow">default</span>: assert(0);
        }

        <span class="keywordflow">return</span> <a class="code" href="virginian_8h.html#ae39e133b80ee1958313531a94cb517d2" title="used to return a function success">VIRG_SUCCESS</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac42c04f0256cd2b6bbc82047e4940e52"></a><!-- doxytag: member="generate.c::select_opplacepass" ref="ac42c04f0256cd2b6bbc82047e4940e52" args="(absop *aop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void select_opplacepass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structabsop.html">absop</a> *&#160;</td>
          <td class="paramname"><em>aop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pass 3 This pass just assigns the proper index to each op </p>

<p>Definition at line <a class="el" href="generate_8c_source.html#l00695">695</a> of file <a class="el" href="generate_8c_source.html">generate.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; aop != NULL; aop = aop-&gt;<a class="code" href="structabsop.html#a5663e74c53509383553e69396dea84b3" title="next op in linked list of ops built during code generation">next</a>) {
                <span class="keywordflow">if</span>(aop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.op != OP_Nop)
                        aop-&gt;<a class="code" href="structabsop.html#a3fe96663f0fa59e05be68db23ab58cf5" title="final fixed index of the operator">index</a> = i++;
                <span class="keywordflow">else</span>
                        aop-&gt;<a class="code" href="structabsop.html#a3fe96663f0fa59e05be68db23ab58cf5" title="final fixed index of the operator">index</a> = i;
        }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2c845e0018d8773884873c4f42bd53b6"></a><!-- doxytag: member="generate.c::select_outputpass" ref="a2c845e0018d8773884873c4f42bd53b6" args="(absop *aop, virg_vm *vm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void select_outputpass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structabsop.html">absop</a> *&#160;</td>
          <td class="paramname"><em>aop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirg__vm.html">virg_vm</a> *&#160;</td>
          <td class="paramname"><em>vm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pass 5 Copy all ops from the linked list to a vm </p>

<p>Definition at line <a class="el" href="generate_8c_source.html#l00770">770</a> of file <a class="el" href="generate_8c_source.html">generate.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="keywordflow">for</span>(; aop != NULL; aop = aop-&gt;<a class="code" href="structabsop.html#a5663e74c53509383553e69396dea84b3" title="next op in linked list of ops built during code generation">next</a>)
                <span class="keywordflow">if</span>(aop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.op != OP_Nop)
                        <a class="code" href="group__vm.html#ga73e734fd1c2210bd54c01fa03f84e949" title="Add an op to a virtual machine&#39;s statement.">virg_vm_addop</a>(vm, aop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.op, aop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p1, aop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p2,
                                aop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p3, aop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p4);
}
</pre></div>
</div>
</div>
<a class="anchor" id="aeb76bd04e58b3b6f9852bff32bfcda38"></a><!-- doxytag: member="generate.c::select_registerpass" ref="aeb76bd04e58b3b6f9852bff32bfcda38" args="(absop *aop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void select_registerpass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structabsop.html">absop</a> *&#160;</td>
          <td class="paramname"><em>aop</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pass 4 This pass resolves the actual location of registers, since they've been rearranged in the original array, and also handles cases where an op jumps to another op. We must replace the pointer with the index to that other op </p>

<p>Definition at line <a class="el" href="generate_8c_source.html#l00710">710</a> of file <a class="el" href="generate_8c_source.html">generate.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="comment">// iterate through all ops</span>
        <span class="keywordflow">for</span>(; aop != NULL; aop = aop-&gt;<a class="code" href="structabsop.html#a5663e74c53509383553e69396dea84b3" title="next op in linked list of ops built during code generation">next</a>) {
                <span class="comment">//fprintf(stderr, &quot;::%i\n&quot;, aop-&gt;op.op);</span>
                <span class="keywordflow">switch</span>(aop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.op) {
                        <span class="keywordflow">case</span> OP_Parallel :
                                <span class="comment">// resolve index of forward op we are pointing to with opptr</span>
                                aop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p3 = aop-&gt;<a class="code" href="structabsop.html#a085d347b23bf1c3a46339594965715b8" title="pointer to another op used if this op can jump to another location">opptr</a>-&gt;<a class="code" href="structabsop.html#a3fe96663f0fa59e05be68db23ab58cf5" title="final fixed index of the operator">index</a> + 1;
                                <span class="keywordflow">break</span>;

                        <span class="keywordflow">case</span> OP_Integer :
                        <span class="keywordflow">case</span> OP_Column :
                        <span class="keywordflow">case</span> OP_Rowid :
                        <span class="keywordflow">case</span> OP_Result :
                        <span class="keywordflow">case</span> OP_Float :
                                <span class="comment">// resolve actual register index</span>
                                aop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p1 = <a class="code" href="generate_8c.html#ae79511fcd661301cd55823fdac5b5e51" title="table of vm registers">reg_table</a>[aop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p1].index;
                                <span class="keywordflow">break</span>;

                        <span class="comment">// these ops resolve 3 registers</span>
                        <span class="keywordflow">case</span> OP_Add :
                        <span class="keywordflow">case</span> OP_Sub :
                        <span class="keywordflow">case</span> OP_Mul :
                        <span class="keywordflow">case</span> OP_Div :
                                aop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p1 = <a class="code" href="generate_8c.html#ae79511fcd661301cd55823fdac5b5e51" title="table of vm registers">reg_table</a>[aop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p1].index;
                                aop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p2 = <a class="code" href="generate_8c.html#ae79511fcd661301cd55823fdac5b5e51" title="table of vm registers">reg_table</a>[aop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p2].index;
                                aop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p3 = <a class="code" href="generate_8c.html#ae79511fcd661301cd55823fdac5b5e51" title="table of vm registers">reg_table</a>[aop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p3].index;
                                <span class="keywordflow">break</span>;

                        <span class="comment">// resolve 2 registers and forward pointing jump location</span>
                        <span class="keywordflow">case</span> OP_Eq :
                        <span class="keywordflow">case</span> OP_Neq :
                        <span class="keywordflow">case</span> OP_Le :
                        <span class="keywordflow">case</span> OP_Lt :
                        <span class="keywordflow">case</span> OP_Ge :
                        <span class="keywordflow">case</span> OP_Gt :
                                aop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p1 = <a class="code" href="generate_8c.html#ae79511fcd661301cd55823fdac5b5e51" title="table of vm registers">reg_table</a>[aop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p1].index;
                                aop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p2 = <a class="code" href="generate_8c.html#ae79511fcd661301cd55823fdac5b5e51" title="table of vm registers">reg_table</a>[aop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p2].index;
                                aop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p3 = aop-&gt;<a class="code" href="structabsop.html#a085d347b23bf1c3a46339594965715b8" title="pointer to another op used if this op can jump to another location">opptr</a>-&gt;<a class="code" href="structabsop.html#a3fe96663f0fa59e05be68db23ab58cf5" title="final fixed index of the operator">index</a>;
                                <span class="keywordflow">break</span>;

                        <span class="comment">// no register use</span>
                        <span class="keywordflow">case</span> OP_Table :
                        <span class="keywordflow">case</span> OP_Invalid :
                        <span class="keywordflow">case</span> OP_ResultColumn :
                        <span class="keywordflow">case</span> OP_Converge :
                        <span class="keywordflow">case</span> OP_Finish :
                        <span class="keywordflow">case</span> OP_Nop :
                                <span class="keywordflow">break</span>;

                        <span class="keywordflow">default</span> :
                                assert(0);
                }
        }
}
</pre></div>
</div>
</div>
<a class="anchor" id="a33ab7485e7a795df8225bd8defbfb5ef"></a><!-- doxytag: member="generate.c::select_resolveopspass" ref="a33ab7485e7a795df8225bd8defbfb5ef" args="(node_select *root)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int select_resolveopspass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode__select.html">node_select</a> *&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pass 1 This pass recurses through all expressions in the queries looking for cases where both sides of an operator are constant values, since these can be simplified to another constant </p>

<p>Definition at line <a class="el" href="generate_8c_source.html#l00376">376</a> of file <a class="el" href="generate_8c_source.html">generate.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <a class="code" href="structnode__resultcol.html" title="Represents a result column used in a SELECT statement.">node_resultcol</a> *col = root-&gt;<a class="code" href="structnode__select.html#a934ac3686e22ca296911742c42247bd0" title="list of result columns, of which there must be at least one">resultcols</a>;

        <span class="comment">// iterate through result columns</span>
        <span class="keywordflow">for</span>(; col != NULL; col = col-&gt;<a class="code" href="structnode__resultcol.html#ab5b614617fffe4584c39f9c793085806" title="pointer to next resultcol in list">next</a>)
                <a class="code" href="generate_8c.html#ac9899b68828759f5eae42dc00af80ad2">select_resolveopspass_recurse</a>(col-&gt;<a class="code" href="structnode__resultcol.html#a52252324055937d2729b964b2eb494e2" title="expression used as result value">expr</a>);

        <span class="comment">// start recursing through any conditions</span>
        <span class="keywordflow">if</span>(root-&gt;<a class="code" href="structnode__select.html#a62057b9735cbf4f75e54fa9d1edc0ecf" title="list of conditions, can be null">conditions</a> != NULL)
                <a class="code" href="generate_8c.html#a39739b571f9e9997018fa974fdc7ecc2">select_resolveopspass_condrecurse</a>(root-&gt;<a class="code" href="structnode__select.html#a62057b9735cbf4f75e54fa9d1edc0ecf" title="list of conditions, can be null">conditions</a>);

        <span class="keywordflow">return</span> <a class="code" href="virginian_8h.html#ae39e133b80ee1958313531a94cb517d2" title="used to return a function success">VIRG_SUCCESS</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a39739b571f9e9997018fa974fdc7ecc2"></a><!-- doxytag: member="generate.c::select_resolveopspass_condrecurse" ref="a39739b571f9e9997018fa974fdc7ecc2" args="(node_condition *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void select_resolveopspass_condrecurse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode__condition.html">node_condition</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This recurses through the tree of conditions, calling another function for any expressions found </p>

<p>Definition at line <a class="el" href="generate_8c_source.html#l00354">354</a> of file <a class="el" href="generate_8c_source.html">generate.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="comment">// go down left and right expression of condition</span>
        <a class="code" href="generate_8c.html#ac9899b68828759f5eae42dc00af80ad2">select_resolveopspass_recurse</a>(x-&gt;<a class="code" href="structnode__condition.html#a4b8af68e68b36b1064209288246ae41f" title="left hand expression for comparison">lhs</a>);
        <a class="code" href="generate_8c.html#ac9899b68828759f5eae42dc00af80ad2">select_resolveopspass_recurse</a>(x-&gt;<a class="code" href="structnode__condition.html#a4522137b9b21c53b944c5e29be476a72" title="right hand expression for comparison">rhs</a>);

        <span class="comment">// recurse through AND</span>
        <span class="keywordflow">if</span>(x-&gt;<a class="code" href="structnode__condition.html#a0fc745ea6013a76abb5e72d84cd810fd" title="AND condition.">andcond</a> != NULL)
                <a class="code" href="generate_8c.html#a39739b571f9e9997018fa974fdc7ecc2">select_resolveopspass_condrecurse</a>(x-&gt;<a class="code" href="structnode__condition.html#a0fc745ea6013a76abb5e72d84cd810fd" title="AND condition.">andcond</a>);

        <span class="comment">// recurse through OR</span>
        <span class="keywordflow">if</span>(x-&gt;<a class="code" href="structnode__condition.html#ab8e4409734a8c903f43681364e8202f5" title="OR condition.">orcond</a> != NULL)
                <a class="code" href="generate_8c.html#a39739b571f9e9997018fa974fdc7ecc2">select_resolveopspass_condrecurse</a>(x-&gt;<a class="code" href="structnode__condition.html#ab8e4409734a8c903f43681364e8202f5" title="OR condition.">orcond</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ac9899b68828759f5eae42dc00af80ad2"></a><!-- doxytag: member="generate.c::select_resolveopspass_recurse" ref="ac9899b68828759f5eae42dc00af80ad2" args="(node_expr *x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void select_resolveopspass_recurse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode__expr.html">node_expr</a> *&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Recurse through a tree of expressions, checking if both sides of an operator are constants. If that is the case, perform the math necessary to simplyify the operation to a single constant </p>

<p>Definition at line <a class="el" href="generate_8c_source.html#l00296">296</a> of file <a class="el" href="generate_8c_source.html">generate.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="comment">// if this expression is not an operation, we can&#39;t go any deeper</span>
        <span class="keywordflow">if</span>(x-&gt;<a class="code" href="structnode__expr.html#a5df61fe9e1d916ec0be94bf54eb98fd2" title="a constant, a column from a data record, or an operation">type</a> != NODE_EXPR_OP)
                <span class="keywordflow">return</span>;

        <span class="comment">// recurse down left and right sides</span>
        <a class="code" href="generate_8c.html#ac9899b68828759f5eae42dc00af80ad2">select_resolveopspass_recurse</a>(x-&gt;<a class="code" href="structnode__expr.html#af714b3267b64e8ad19bd95699106d285" title="left hand side of operation">lhs</a>);
        <a class="code" href="generate_8c.html#ac9899b68828759f5eae42dc00af80ad2">select_resolveopspass_recurse</a>(x-&gt;<a class="code" href="structnode__expr.html#a7934fcd17d71d6e6090a10420c1876a5" title="right hand side of operation">rhs</a>);
        
        <span class="comment">// both left and right are constants</span>
        <span class="keywordflow">if</span>((x-&gt;<a class="code" href="structnode__expr.html#af714b3267b64e8ad19bd95699106d285" title="left hand side of operation">lhs</a>-&gt;<a class="code" href="structnode__expr.html#a5df61fe9e1d916ec0be94bf54eb98fd2" title="a constant, a column from a data record, or an operation">type</a> != <a class="code" href="node_8h.html#a7479e9c639bfd5e2f4f27aaa37e18b25" title="possible datatypes for an expression">NODE_EXPR_INT</a> &amp;&amp; x-&gt;<a class="code" href="structnode__expr.html#af714b3267b64e8ad19bd95699106d285" title="left hand side of operation">lhs</a>-&gt;<a class="code" href="structnode__expr.html#a5df61fe9e1d916ec0be94bf54eb98fd2" title="a constant, a column from a data record, or an operation">type</a> != NODE_EXPR_FLOAT) ||
                (x-&gt;<a class="code" href="structnode__expr.html#a7934fcd17d71d6e6090a10420c1876a5" title="right hand side of operation">rhs</a>-&gt;<a class="code" href="structnode__expr.html#a5df61fe9e1d916ec0be94bf54eb98fd2" title="a constant, a column from a data record, or an operation">type</a> != <a class="code" href="node_8h.html#a7479e9c639bfd5e2f4f27aaa37e18b25" title="possible datatypes for an expression">NODE_EXPR_INT</a> &amp;&amp; x-&gt;<a class="code" href="structnode__expr.html#a7934fcd17d71d6e6090a10420c1876a5" title="right hand side of operation">rhs</a>-&gt;<a class="code" href="structnode__expr.html#a5df61fe9e1d916ec0be94bf54eb98fd2" title="a constant, a column from a data record, or an operation">type</a> != NODE_EXPR_FLOAT))
                <span class="keywordflow">return</span>;

        assert(nodetotype[<a class="code" href="node_8h.html#a7479e9c639bfd5e2f4f27aaa37e18b25" title="possible datatypes for an expression">NODE_EXPR_INT</a>] == VIRG_INT);
        assert(nodetotype[NODE_EXPR_FLOAT] == VIRG_FLOAT);

        <span class="comment">// since the constants may be of different types, we must output the result</span>
        <span class="comment">// in the more general type</span>
        <a class="code" href="virginian_8h.html#a5edb977d9e195d5df43f1757f311292b" title="enumeration of all variable types used by the database">virg_t</a> targettype = virg_generalizetype(
                nodetotype[x-&gt;<a class="code" href="structnode__expr.html#af714b3267b64e8ad19bd95699106d285" title="left hand side of operation">lhs</a>-&gt;<a class="code" href="structnode__expr.html#a5df61fe9e1d916ec0be94bf54eb98fd2" title="a constant, a column from a data record, or an operation">type</a>], nodetotype[x-&gt;<a class="code" href="structnode__expr.html#a7934fcd17d71d6e6090a10420c1876a5" title="right hand side of operation">rhs</a>-&gt;<a class="code" href="structnode__expr.html#a5df61fe9e1d916ec0be94bf54eb98fd2" title="a constant, a column from a data record, or an operation">type</a>]);

        <span class="keywordflow">switch</span>(targettype) {
                <span class="keywordflow">case</span> VIRG_INT :
                        {
                                <span class="comment">// cast both values</span>
                                <span class="keywordtype">int</span> op1 = expr_valint(x-&gt;<a class="code" href="structnode__expr.html#af714b3267b64e8ad19bd95699106d285" title="left hand side of operation">lhs</a>);
                                <span class="keywordtype">int</span> op2 = expr_valint(x-&gt;<a class="code" href="structnode__expr.html#a7934fcd17d71d6e6090a10420c1876a5" title="right hand side of operation">rhs</a>);
                                <span class="keywordtype">int</span> result;
                                <span class="comment">// perform the operation</span>
                                RUNOP(x-&gt;val.i);
                                <span class="comment">// set this node to be a constant of the result value</span>
                                x-&gt;<a class="code" href="structnode__expr.html#a5df61fe9e1d916ec0be94bf54eb98fd2" title="a constant, a column from a data record, or an operation">type</a> = <a class="code" href="node_8h.html#a7479e9c639bfd5e2f4f27aaa37e18b25" title="possible datatypes for an expression">NODE_EXPR_INT</a>;
                                x-&gt;val.i = result;
                        }
                        <span class="keywordflow">break</span>;

                <span class="keywordflow">case</span> VIRG_FLOAT :
                        {
                                <span class="keywordtype">float</span> op1 = expr_valint(x-&gt;<a class="code" href="structnode__expr.html#af714b3267b64e8ad19bd95699106d285" title="left hand side of operation">lhs</a>);
                                <span class="keywordtype">float</span> op2 = expr_valint(x-&gt;<a class="code" href="structnode__expr.html#a7934fcd17d71d6e6090a10420c1876a5" title="right hand side of operation">rhs</a>);
                                <span class="keywordtype">float</span> result;
                                RUNOP(x-&gt;val.i);
                                x-&gt;<a class="code" href="structnode__expr.html#a5df61fe9e1d916ec0be94bf54eb98fd2" title="a constant, a column from a data record, or an operation">type</a> = NODE_EXPR_FLOAT;
                                x-&gt;val.f = result;
                        }
                        <span class="keywordflow">break</span>;

                <span class="keywordflow">default</span> : assert(0);
        }

        x-&gt;<a class="code" href="structnode__expr.html#a3ee9ddd1ceb400b586e6ee02412a131f" title="datatype derived from the constant type, column type, or operation type">datatype</a> = targettype;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab02866ad29709e513f58d61ce1b8de82"></a><!-- doxytag: member="generate.c::select_structurepass" ref="ab02866ad29709e513f58d61ce1b8de82" args="(node_select *root, absop **ops)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int select_structurepass </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode__select.html">node_select</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structabsop.html">absop</a> **&#160;</td>
          <td class="paramname"><em>ops</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Pass 2 This pass creates the basic structure of a select statement expressed in opcodes. Select statements do the following:</p>
<ul>
<li>Choose a certain table</li>
<li>Initialize result columns</li>
<li>Begin the parallel section</li>
<li>Resolve the expressions that represent each result column</li>
<li>Resolve all the conditions that filter the results of the select</li>
<li>Output result rows to the results tablet</li>
<li>Exit </li>
</ul>

<p>Definition at line <a class="el" href="generate_8c_source.html#l00591">591</a> of file <a class="el" href="generate_8c_source.html">generate.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <a class="code" href="generate_8c.html#a66cae64bfc2d94b22085d77d4213cf2c" title="counter of currently used vm registers">regcounter</a> = 0;
        <span class="comment">// linked list representing the statement</span>
        <a class="code" href="structabsop.html" title="Abstracted virg_op structure with metadata used in code generation.">absop</a> *ops_list = NULL;
        <a class="code" href="structabsop.html" title="Abstracted virg_op structure with metadata used in code generation.">absop</a> *newop;

        <span class="comment">// add table initialization</span>
        newop = <a class="code" href="generate_8c.html#a23c98d5a7e655021e2243f1732dab39c">create_absop</a>(OP_Table, root-&gt;<a class="code" href="structnode__select.html#ac85a4cfc3c8b11c4ef1619f2071a2572" title="id of table for select statement">table_id</a>, 0, 0, NULL);
        <a class="code" href="generate_8c.html#a60e61c0947f825c1872236d5c8bb3957" title="appends absop to a linked list of absops used to build the statement">append</a>(&amp;ops_list, newop);

        <span class="comment">// add result column setup</span>
        <a class="code" href="structnode__resultcol.html" title="Represents a result column used in a SELECT statement.">node_resultcol</a> *currcol = root-&gt;<a class="code" href="structnode__select.html#a934ac3686e22ca296911742c42247bd0" title="list of result columns, of which there must be at least one">resultcols</a>;
        assert(currcol != NULL);

        <span class="comment">// iterate through each result column</span>
        <span class="keywordflow">for</span>(; currcol != NULL; currcol = currcol-&gt;<a class="code" href="structnode__resultcol.html#ab5b614617fffe4584c39f9c793085806" title="pointer to next resultcol in list">next</a>) {
                <span class="comment">// create buffer for this column&#39;s name</span>
                <span class="keywordtype">char</span> *buff = malloc(<a class="code" href="virginian_8h.html#a2cccd75830388d7a23d0dc8dca454f57" title="maximum column name length supported">VIRG_MAX_COLUMN_NAME</a>);
                strcpy(buff, currcol-&gt;<a class="code" href="structnode__resultcol.html#a577474f26bc83b852ad24a08d2e049a5" title="label for result column">output_name</a>);

                <span class="comment">// create resultcolumn op</span>
                newop = <a class="code" href="generate_8c.html#a23c98d5a7e655021e2243f1732dab39c">create_absop</a>(OP_ResultColumn,
                        currcol-&gt;<a class="code" href="structnode__resultcol.html#a52252324055937d2729b964b2eb494e2" title="expression used as result value">expr</a>-&gt;<a class="code" href="structnode__expr.html#a3ee9ddd1ceb400b586e6ee02412a131f" title="datatype derived from the constant type, column type, or operation type">datatype</a>, 0, 0, NULL);
                newop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p4.s = buff;
                <a class="code" href="generate_8c.html#a60e61c0947f825c1872236d5c8bb3957" title="appends absop to a linked list of absops used to build the statement">append</a>(&amp;ops_list, newop);
        }

        <span class="comment">// Begin parallel section, with opcodes for outputting results and exiting</span>
        <span class="comment">// the parallel section which we will later append to the statement.</span>
        <span class="comment">// We add them now so that forward pointing opcodes can use them</span>
        <a class="code" href="structabsop.html" title="Abstracted virg_op structure with metadata used in code generation.">absop</a> *result = <a class="code" href="generate_8c.html#a23c98d5a7e655021e2243f1732dab39c">create_absop</a>(OP_Result, 0, 0, 0, NULL);
        <a class="code" href="structabsop.html" title="Abstracted virg_op structure with metadata used in code generation.">absop</a> *converge = <a class="code" href="generate_8c.html#a23c98d5a7e655021e2243f1732dab39c">create_absop</a>(OP_Converge, 0, 0, 0, NULL);
        newop = <a class="code" href="generate_8c.html#a23c98d5a7e655021e2243f1732dab39c">create_absop</a>(OP_Parallel, 0, 0, 0, converge);
        <a class="code" href="generate_8c.html#a60e61c0947f825c1872236d5c8bb3957" title="appends absop to a linked list of absops used to build the statement">append</a>(&amp;ops_list, newop);

        <span class="comment">// resolve conditions</span>
        <span class="keywordflow">if</span>(root-&gt;<a class="code" href="structnode__select.html#a62057b9735cbf4f75e54fa9d1edc0ecf" title="list of conditions, can be null">conditions</a> != NULL) {
                <a class="code" href="structabsop.html" title="Abstracted virg_op structure with metadata used in code generation.">absop</a> *stub = <a class="code" href="generate_8c.html#a23c98d5a7e655021e2243f1732dab39c">create_absop</a>(OP_Nop, 0, 0, 0, NULL);

                <span class="comment">// recurse through condition tree, adding opcodes as necessary</span>
                <a class="code" href="generate_8c.html#a141d9a0b0b60fc33babd46c91f12828a">select_structurepass_condrecurse</a>(root-&gt;<a class="code" href="structnode__select.html#a62057b9735cbf4f75e54fa9d1edc0ecf" title="list of conditions, can be null">conditions</a>, ops_list,
                        stub, result, NULL);

                <span class="comment">// since conditions jump forward to output results, anything that doesnt</span>
                <span class="comment">// jump is assumed to be invalid</span>
                newop = <a class="code" href="generate_8c.html#a23c98d5a7e655021e2243f1732dab39c">create_absop</a>(OP_Invalid, 0, 0, 0, NULL);
                <a class="code" href="generate_8c.html#a60e61c0947f825c1872236d5c8bb3957" title="appends absop to a linked list of absops used to build the statement">append</a>(&amp;ops_list, newop);

                <a class="code" href="generate_8c.html#a60e61c0947f825c1872236d5c8bb3957" title="appends absop to a linked list of absops used to build the statement">append</a>(&amp;ops_list, stub);
        }

        <span class="comment">// resolve result column expressions</span>
        currcol = root-&gt;<a class="code" href="structnode__select.html#a934ac3686e22ca296911742c42247bd0" title="list of result columns, of which there must be at least one">resultcols</a>;
        <span class="keywordflow">for</span>(; currcol != NULL; currcol = currcol-&gt;<a class="code" href="structnode__resultcol.html#ab5b614617fffe4584c39f9c793085806" title="pointer to next resultcol in list">next</a>) {
                <span class="keywordtype">int</span> <a class="code" href="structreg.html" title="connects a vm register to an expression">reg</a> = <a class="code" href="generate_8c.html#ab8eb77f77473dd11466aacb580a3e666">select_structurepass_expr</a>(ops_list, currcol-&gt;<a class="code" href="structnode__resultcol.html#a52252324055937d2729b964b2eb494e2" title="expression used as result value">expr</a>);
                currcol-&gt;<a class="code" href="structnode__resultcol.html#a2f0fa5d8f78d7715d36f4d9bd49fa19d" title="register holding the result expression value">output_reg</a> = <a class="code" href="generate_8c.html#ab2de1d48751c7bda364596eca745d491" title="connects a vm register to an expression">reg</a>;
        }

        <span class="comment">// rearrange registers so output columns are contiguous</span>
        <span class="comment">// TODO check to make sure resultcols dont use the same reg</span>
        <span class="comment">//              copy if they do</span>
        <a class="code" href="generate_8c.html#aa40128d0c62090fdedecf8c7255b1be8" title="assigns each registers index based on its position in register table">regindex</a>();
        currcol = root-&gt;<a class="code" href="structnode__select.html#a934ac3686e22ca296911742c42247bd0" title="list of result columns, of which there must be at least one">resultcols</a>;
        <span class="keywordtype">int</span> numrescols = 0;

        <span class="keywordflow">for</span>(; currcol != NULL; currcol = currcol-&gt;<a class="code" href="structnode__resultcol.html#ab5b614617fffe4584c39f9c793085806" title="pointer to next resultcol in list">next</a>) {
                numrescols++;
                <span class="keywordtype">int</span> i = currcol-&gt;<a class="code" href="structnode__resultcol.html#a2f0fa5d8f78d7715d36f4d9bd49fa19d" title="register holding the result expression value">output_reg</a>;

                <span class="comment">// already at back of registers</span>
                <span class="keywordflow">if</span>(<a class="code" href="generate_8c.html#ae79511fcd661301cd55823fdac5b5e51" title="table of vm registers">reg_table</a>[i].index == <a class="code" href="generate_8c.html#a66cae64bfc2d94b22085d77d4213cf2c" title="counter of currently used vm registers">regcounter</a> - 1)
                        <span class="keywordflow">continue</span>;

                <span class="keywordtype">int</span> oldindex = <a class="code" href="generate_8c.html#ae79511fcd661301cd55823fdac5b5e51" title="table of vm registers">reg_table</a>[i].index;
                <span class="keywordtype">int</span> oldi = i;
                <a class="code" href="generate_8c.html#ae79511fcd661301cd55823fdac5b5e51" title="table of vm registers">reg_table</a>[i].index = <a class="code" href="generate_8c.html#a66cae64bfc2d94b22085d77d4213cf2c" title="counter of currently used vm registers">regcounter</a> - 1;

                <span class="comment">//printf(&quot;column %i old %i new %i\n&quot;, numrescols - 1, oldindex, regcounter - 1);</span>

                <span class="keywordflow">for</span>(i = 0; i &lt; <a class="code" href="generate_8c.html#a66cae64bfc2d94b22085d77d4213cf2c" title="counter of currently used vm registers">regcounter</a>; i++)
                        <span class="keywordflow">if</span>(i != oldi &amp;&amp; <a class="code" href="generate_8c.html#ae79511fcd661301cd55823fdac5b5e51" title="table of vm registers">reg_table</a>[i].index &gt; oldindex)
                                <a class="code" href="generate_8c.html#ae79511fcd661301cd55823fdac5b5e51" title="table of vm registers">reg_table</a>[i].index--;
        }

        <span class="comment">// output result columns</span>
        result-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p1 = root-&gt;<a class="code" href="structnode__select.html#a934ac3686e22ca296911742c42247bd0" title="list of result columns, of which there must be at least one">resultcols</a>-&gt;<a class="code" href="structnode__resultcol.html#a2f0fa5d8f78d7715d36f4d9bd49fa19d" title="register holding the result expression value">output_reg</a>;
        result-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p2 = numrescols;
        <a class="code" href="generate_8c.html#a60e61c0947f825c1872236d5c8bb3957" title="appends absop to a linked list of absops used to build the statement">append</a>(&amp;ops_list, result);

        <span class="comment">// finish up parallel section</span>
        <a class="code" href="generate_8c.html#a60e61c0947f825c1872236d5c8bb3957" title="appends absop to a linked list of absops used to build the statement">append</a>(&amp;ops_list, converge);

        <span class="comment">// add finish op</span>
        newop = <a class="code" href="generate_8c.html#a23c98d5a7e655021e2243f1732dab39c">create_absop</a>(OP_Finish, 0, 0, 0, NULL);
        <a class="code" href="generate_8c.html#a60e61c0947f825c1872236d5c8bb3957" title="appends absop to a linked list of absops used to build the statement">append</a>(&amp;ops_list, newop);

        ops[0] = ops_list;
        <span class="keywordflow">return</span> <a class="code" href="virginian_8h.html#ae39e133b80ee1958313531a94cb517d2" title="used to return a function success">VIRG_SUCCESS</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a141d9a0b0b60fc33babd46c91f12828a"></a><!-- doxytag: member="generate.c::select_structurepass_condrecurse" ref="a141d9a0b0b60fc33babd46c91f12828a" args="(node_condition *x, absop *ops_list, absop *onsuccess, absop *onfailure, absop *newop)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structabsop.html">absop</a>* select_structurepass_condrecurse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode__condition.html">node_condition</a> *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structabsop.html">absop</a> *&#160;</td>
          <td class="paramname"><em>ops_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structabsop.html">absop</a> *&#160;</td>
          <td class="paramname"><em>onsuccess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structabsop.html">absop</a> *&#160;</td>
          <td class="paramname"><em>onfailure</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structabsop.html">absop</a> *&#160;</td>
          <td class="paramname"><em>newop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This function turns a tree of WHERE clause conditions into opcodes for filtering results. At a high level, this works in the following manner. Each condition is an operator that compares two expressions with a boolean result. Conditions can also have AND and OR conditions, thus forming a tree. If a condition node has an AND condition, we know that failure of this node's condition invalidates the clause, thus we jump forward to the next condition to be evaluated, possibly the end of the conditions. If this node has no children or is group with an OR condition at a higher order of operations than the AND, then we jump when this condition evaluates to true. In this way we recurse down a tree of both AND and OR conditions. </p>

<p>Definition at line <a class="el" href="generate_8c_source.html#l00477">477</a> of file <a class="el" href="generate_8c_source.html">generate.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="comment">// resolve the left and right side expressions of the condition</span>
        <span class="keywordtype">int</span> reg1 = <a class="code" href="generate_8c.html#ab8eb77f77473dd11466aacb580a3e666">select_structurepass_expr</a>(ops_list, x-&gt;<a class="code" href="structnode__condition.html#a4b8af68e68b36b1064209288246ae41f" title="left hand expression for comparison">lhs</a>);
        <span class="keywordtype">int</span> reg2 = <a class="code" href="generate_8c.html#ab8eb77f77473dd11466aacb580a3e666">select_structurepass_expr</a>(ops_list, x-&gt;<a class="code" href="structnode__condition.html#a4522137b9b21c53b944c5e29be476a72" title="right hand expression for comparison">rhs</a>);

        <span class="keywordtype">int</span> op;

        <span class="comment">// if this is a leaf node or the OR has higher precedence than the AND</span>
        <span class="keywordflow">if</span>(x-&gt;<a class="code" href="structnode__condition.html#a0fc745ea6013a76abb5e72d84cd810fd" title="AND condition.">andcond</a> == NULL || (x-&gt;<a class="code" href="structnode__condition.html#ab8e4409734a8c903f43681364e8202f5" title="OR condition.">orcond</a> != NULL &amp;&amp; x-&gt;<a class="code" href="structnode__condition.html#a1b87cd1ddba195eb97c19235713f8858" title="boolean true ifOR condition has a higher precedence than AND condition">orfirst</a>)) {
                
                <span class="comment">// jump on success</span>
                <span class="keywordflow">switch</span>(x-&gt;<a class="code" href="structnode__condition.html#a00b9344d759f006ea7e42283cbe57470" title="comparison operater">type</a>) {
                        <span class="keywordflow">case</span> <a class="code" href="node_8h.html#a8668f93175b68c8ebbc5f0c4a6d414bf" title="possible comparison operators used in a query condition">NODE_COND_EQ</a>: op = OP_Eq; <span class="keywordflow">break</span>;
                        <span class="keywordflow">case</span> NODE_COND_NE: op = OP_Neq; <span class="keywordflow">break</span>;
                        <span class="keywordflow">case</span> NODE_COND_LT: op = OP_Lt; <span class="keywordflow">break</span>;
                        <span class="keywordflow">case</span> NODE_COND_LE: op = OP_Le; <span class="keywordflow">break</span>;
                        <span class="keywordflow">case</span> NODE_COND_GT: op = OP_Gt; <span class="keywordflow">break</span>;
                        <span class="keywordflow">case</span> NODE_COND_GE: op = OP_Ge; <span class="keywordflow">break</span>;
                        <span class="keywordflow">default</span>: assert(0);
                }

                <a class="code" href="structabsop.html" title="Abstracted virg_op structure with metadata used in code generation.">absop</a> *andop = NULL;

                <span class="comment">// if there is a lower precedence AND, we know a successful OR jumps to</span>
                <span class="comment">// it, so we create it and use it later</span>
                <span class="keywordflow">if</span>(x-&gt;<a class="code" href="structnode__condition.html#a0fc745ea6013a76abb5e72d84cd810fd" title="AND condition.">andcond</a> != NULL) {
                        andop = <a class="code" href="generate_8c.html#a23c98d5a7e655021e2243f1732dab39c">create_absop</a>(OP_Nop, 0, 0, 0, NULL);
                        onsuccess = andop;
                }

                <span class="comment">// if we have not been handed an op from above, we create it</span>
                <span class="keywordflow">if</span>(newop == NULL)
                        newop = <a class="code" href="generate_8c.html#a23c98d5a7e655021e2243f1732dab39c">create_absop</a>(OP_Nop, 0, 0, 0, NULL);

                <span class="comment">// these comparisons are of the pattern</span>
                <span class="comment">// OP, value 1 register, value 2 register, jump location if comparison</span>
                <span class="comment">// evaluates to true, validity if op evaluates to true</span>
                newop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.op = op;
                newop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p1 = reg1;
                newop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p2 = reg2;
                newop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p4.i = 1;
                newop-&gt;<a class="code" href="structabsop.html#a085d347b23bf1c3a46339594965715b8" title="pointer to another op used if this op can jump to another location">opptr</a> = onsuccess;
                <a class="code" href="generate_8c.html#a60e61c0947f825c1872236d5c8bb3957" title="appends absop to a linked list of absops used to build the statement">append</a>(&amp;ops_list, newop);

                <span class="comment">// if this is not a leaf node</span>
                <span class="keywordflow">if</span>(x-&gt;<a class="code" href="structnode__condition.html#ab8e4409734a8c903f43681364e8202f5" title="OR condition.">orcond</a> != NULL)
                        <a class="code" href="generate_8c.html#a141d9a0b0b60fc33babd46c91f12828a">select_structurepass_condrecurse</a>(x-&gt;<a class="code" href="structnode__condition.html#ab8e4409734a8c903f43681364e8202f5" title="OR condition.">orcond</a>, ops_list,
                                onsuccess, onfailure, NULL);

                <span class="comment">// recurse down lower precedence AND</span>
                <span class="keywordflow">if</span>(x-&gt;<a class="code" href="structnode__condition.html#a0fc745ea6013a76abb5e72d84cd810fd" title="AND condition.">andcond</a> != NULL)
                        <a class="code" href="generate_8c.html#a141d9a0b0b60fc33babd46c91f12828a">select_structurepass_condrecurse</a>(x-&gt;<a class="code" href="structnode__condition.html#a0fc745ea6013a76abb5e72d84cd810fd" title="AND condition.">andcond</a>, ops_list,
                                onfailure, onfailure, andop);
        }
        <span class="comment">// this must be part of an AND, we fail if any condition fails</span>
        <span class="keywordflow">else</span> {
                <span class="comment">// jump on failure</span>
                <span class="keywordflow">switch</span>(x-&gt;<a class="code" href="structnode__condition.html#a00b9344d759f006ea7e42283cbe57470" title="comparison operater">type</a>) {
                        <span class="keywordflow">case</span> <a class="code" href="node_8h.html#a8668f93175b68c8ebbc5f0c4a6d414bf" title="possible comparison operators used in a query condition">NODE_COND_EQ</a>: op = OP_Neq; <span class="keywordflow">break</span>;
                        <span class="keywordflow">case</span> NODE_COND_NE: op = OP_Eq; <span class="keywordflow">break</span>;
                        <span class="keywordflow">case</span> NODE_COND_LT: op = OP_Ge; <span class="keywordflow">break</span>;
                        <span class="keywordflow">case</span> NODE_COND_LE: op = OP_Gt; <span class="keywordflow">break</span>;
                        <span class="keywordflow">case</span> NODE_COND_GT: op = OP_Le; <span class="keywordflow">break</span>;
                        <span class="keywordflow">case</span> NODE_COND_GE: op = OP_Lt; <span class="keywordflow">break</span>;
                        <span class="keywordflow">default</span>: assert(0);
                }

                <a class="code" href="structabsop.html" title="Abstracted virg_op structure with metadata used in code generation.">absop</a> *orop = NULL;

                <span class="comment">// if there is an OR, we create it and use it later</span>
                <span class="keywordflow">if</span>(x-&gt;<a class="code" href="structnode__condition.html#ab8e4409734a8c903f43681364e8202f5" title="OR condition.">orcond</a> != NULL) {
                        orop = <a class="code" href="generate_8c.html#a23c98d5a7e655021e2243f1732dab39c">create_absop</a>(OP_Nop, 0, 0, 0, NULL);
                        onfailure = orop;
                }

                <span class="comment">// if we have not been handed an op from above, we create it</span>
                <span class="keywordflow">if</span>(newop == NULL)
                        newop = <a class="code" href="generate_8c.html#a23c98d5a7e655021e2243f1732dab39c">create_absop</a>(OP_Nop, 0, 0, 0, NULL);

                <span class="comment">// same pattern as above</span>
                newop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.op = op;
                newop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p1 = reg1;
                newop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p2 = reg2;
                newop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p4.i = 0;
                newop-&gt;<a class="code" href="structabsop.html#a085d347b23bf1c3a46339594965715b8" title="pointer to another op used if this op can jump to another location">opptr</a> = onfailure;
                <a class="code" href="generate_8c.html#a60e61c0947f825c1872236d5c8bb3957" title="appends absop to a linked list of absops used to build the statement">append</a>(&amp;ops_list, newop);

                <span class="comment">// recurse down other AND, jumping to exit or possible the OR from above</span>
                <span class="keywordflow">if</span>(x-&gt;<a class="code" href="structnode__condition.html#a0fc745ea6013a76abb5e72d84cd810fd" title="AND condition.">andcond</a> != NULL)
                        <a class="code" href="generate_8c.html#a141d9a0b0b60fc33babd46c91f12828a">select_structurepass_condrecurse</a>(x-&gt;<a class="code" href="structnode__condition.html#a0fc745ea6013a76abb5e72d84cd810fd" title="AND condition.">andcond</a>, ops_list,
                                onsuccess, onfailure, NULL);

                <span class="comment">// if we have an OR condition, recurse to it</span>
                <span class="keywordflow">if</span>(x-&gt;<a class="code" href="structnode__condition.html#ab8e4409734a8c903f43681364e8202f5" title="OR condition.">orcond</a> != NULL)
                        <a class="code" href="generate_8c.html#a141d9a0b0b60fc33babd46c91f12828a">select_structurepass_condrecurse</a>(x-&gt;<a class="code" href="structnode__condition.html#ab8e4409734a8c903f43681364e8202f5" title="OR condition.">orcond</a>, ops_list,
                                onsuccess, onfailure, orop);
        }
        
        <span class="keywordflow">return</span> newop;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ab8eb77f77473dd11466aacb580a3e666"></a><!-- doxytag: member="generate.c::select_structurepass_expr" ref="ab8eb77f77473dd11466aacb580a3e666" args="(absop *ops_list, node_expr *expr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int select_structurepass_expr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structabsop.html">absop</a> *&#160;</td>
          <td class="paramname"><em>ops_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structnode__expr.html">node_expr</a> *&#160;</td>
          <td class="paramname"><em>expr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Recursively resolve expressions and assign them to a register so they can be accessed either for a result column or condition. </p>

<p>Definition at line <a class="el" href="generate_8c_source.html#l00394">394</a> of file <a class="el" href="generate_8c_source.html">generate.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="comment">// check if a register already contains an identical expression</span>
        <span class="comment">// if so, we return that reg</span>
        <span class="keywordtype">int</span> <a class="code" href="structreg.html" title="connects a vm register to an expression">reg</a> = <a class="code" href="generate_8c.html#aefe7d633da51e9bf7502c2e51a972b9d" title="loops through registers to check if the passed expression is identical">expr_findreg</a>(expr);
        <span class="keywordflow">if</span>(reg != -1)
                <span class="keywordflow">return</span> <a class="code" href="generate_8c.html#ab2de1d48751c7bda364596eca745d491" title="connects a vm register to an expression">reg</a>;

        <a class="code" href="structabsop.html" title="Abstracted virg_op structure with metadata used in code generation.">absop</a> *newop;
        <span class="keywordtype">int</span> reg1, reg2;

        <span class="comment">// switch on the type of the expression</span>
        <span class="keywordflow">switch</span>(expr-&gt;<a class="code" href="structnode__expr.html#a5df61fe9e1d916ec0be94bf54eb98fd2" title="a constant, a column from a data record, or an operation">type</a>) {
                <span class="comment">// constant integer</span>
                <span class="keywordflow">case</span> <a class="code" href="node_8h.html#a7479e9c639bfd5e2f4f27aaa37e18b25" title="possible datatypes for an expression">NODE_EXPR_INT</a>:
                        reg = <a class="code" href="generate_8c.html#a8f902c7a6f7c3b528fbd7d74dc344de8" title="get first unassigned register and increment counter">getreg</a>();
                        newop = <a class="code" href="generate_8c.html#a23c98d5a7e655021e2243f1732dab39c">create_absop</a>(OP_Integer, reg, expr-&gt;val.i, 0, NULL);
                        <a class="code" href="generate_8c.html#a60e61c0947f825c1872236d5c8bb3957" title="appends absop to a linked list of absops used to build the statement">append</a>(&amp;ops_list, newop);
                        <span class="keywordflow">break</span>;

                <span class="comment">// constant float</span>
                <span class="keywordflow">case</span> NODE_EXPR_FLOAT:
                        reg = <a class="code" href="generate_8c.html#a8f902c7a6f7c3b528fbd7d74dc344de8" title="get first unassigned register and increment counter">getreg</a>();
                        newop = <a class="code" href="generate_8c.html#a23c98d5a7e655021e2243f1732dab39c">create_absop</a>(OP_Float, reg, 0, 0, NULL);
                        newop-&gt;<a class="code" href="structabsop.html#a5ebfb3c922cabbc6435472b28749cad7" title="operator proper">op</a>.p4.f = expr-&gt;val.f;
                        <a class="code" href="generate_8c.html#a60e61c0947f825c1872236d5c8bb3957" title="appends absop to a linked list of absops used to build the statement">append</a>(&amp;ops_list, newop);
                        <span class="keywordflow">break</span>;

                <span class="keywordflow">case</span> NODE_EXPR_STRING:
                        assert(0);
                        <span class="keywordflow">break</span>;

                <span class="comment">// this node is an operation between two expressions</span>
                <span class="keywordflow">case</span> NODE_EXPR_OP:
                        <span class="comment">// recurse down both expressions</span>
                        reg1 = <a class="code" href="generate_8c.html#ab8eb77f77473dd11466aacb580a3e666">select_structurepass_expr</a>(ops_list, expr-&gt;<a class="code" href="structnode__expr.html#af714b3267b64e8ad19bd95699106d285" title="left hand side of operation">lhs</a>);
                        reg2 = <a class="code" href="generate_8c.html#ab8eb77f77473dd11466aacb580a3e666">select_structurepass_expr</a>(ops_list, expr-&gt;<a class="code" href="structnode__expr.html#a7934fcd17d71d6e6090a10420c1876a5" title="right hand side of operation">rhs</a>);
                        <span class="comment">// TODO handle runtime type casting</span>
                        
                        reg = <a class="code" href="generate_8c.html#a8f902c7a6f7c3b528fbd7d74dc344de8" title="get first unassigned register and increment counter">getreg</a>();
                        <span class="keywordtype">int</span> op;

                        <span class="comment">// add the math operation opcode</span>
                        <span class="keywordflow">switch</span>(expr-&gt;val.i) {
                                <span class="keywordflow">case</span> <a class="code" href="node_8h.html#a80595e22f59903ad8ac7a5d4ba85e80f" title="possible expression oprators">NODE_OP_PLUS</a> : op = OP_Add; <span class="keywordflow">break</span>;
                                <span class="keywordflow">case</span> NODE_OP_MINUS : op = OP_Sub; <span class="keywordflow">break</span>;
                                <span class="keywordflow">case</span> NODE_OP_MUL : op = OP_Mul; <span class="keywordflow">break</span>;
                                <span class="keywordflow">case</span> NODE_OP_DIV : op = OP_Div; <span class="keywordflow">break</span>;
                                <span class="keywordflow">default</span>: assert(0);
                        }

                        newop = <a class="code" href="generate_8c.html#a23c98d5a7e655021e2243f1732dab39c">create_absop</a>(op, reg, reg1, reg2, NULL);
                        <a class="code" href="generate_8c.html#a60e61c0947f825c1872236d5c8bb3957" title="appends absop to a linked list of absops used to build the statement">append</a>(&amp;ops_list, newop);
                        <span class="keywordflow">break</span>;

                <span class="comment">// this expression is a value loaded from a column at runtime</span>
                <span class="keywordflow">case</span> NODE_EXPR_COLUMN:
                        reg = <a class="code" href="generate_8c.html#a8f902c7a6f7c3b528fbd7d74dc344de8" title="get first unassigned register and increment counter">getreg</a>();
                        <span class="keywordflow">if</span>(expr-&gt;<a class="code" href="structnode__expr.html#aa4c9608320b6252fdd471e25921da73c" title="if this expression is a column type, note whether that column is id">iskey</a>)
                                newop = <a class="code" href="generate_8c.html#a23c98d5a7e655021e2243f1732dab39c">create_absop</a>(OP_Rowid, reg, 0, 0, NULL);
                        <span class="keywordflow">else</span>
                                newop = <a class="code" href="generate_8c.html#a23c98d5a7e655021e2243f1732dab39c">create_absop</a>(OP_Column, reg, expr-&gt;val.u, 0, NULL);
                        <a class="code" href="generate_8c.html#a60e61c0947f825c1872236d5c8bb3957" title="appends absop to a linked list of absops used to build the statement">append</a>(&amp;ops_list, newop);
                        <span class="keywordflow">break</span>;
        }

        <span class="comment">// assign the register to this expression</span>
        <a class="code" href="generate_8c.html#ae79511fcd661301cd55823fdac5b5e51" title="table of vm registers">reg_table</a>[<a class="code" href="generate_8c.html#ab2de1d48751c7bda364596eca745d491" title="connects a vm register to an expression">reg</a>].expr = expr;

        <span class="keywordflow">return</span> <a class="code" href="generate_8c.html#ab2de1d48751c7bda364596eca745d491" title="connects a vm register to an expression">reg</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a2a8a0e487b18c48216cf4f0944bd2d6e"></a><!-- doxytag: member="generate.c::virg_sql_generate" ref="a2a8a0e487b18c48216cf4f0944bd2d6e" args="(virg_node_root *root, virg_vm *vm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int virg_sql_generate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvirg__node__root.html">virg_node_root</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirg__vm.html">virg_vm</a> *&#160;</td>
          <td class="paramname"><em>vm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generate opcodes from parsed sql tree. </p>
<p>generate SQL opcode statement given an AST</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Pointer to the state struct of the database system </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>VIRG_SUCCESS or VIRG_FAIL depending on errors during the function call </dd></dl>

<p>Definition at line <a class="el" href="generate_8c_source.html#l00820">820</a> of file <a class="el" href="generate_8c_source.html">generate.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="keywordflow">switch</span>(root-&gt;<a class="code" href="structvirg__node__root.html#aed631be6474a0c419f1ac36da28db6a0" title="type of query for statement">query_type</a>) {
                <span class="keywordflow">case</span> <a class="code" href="node_8h.html#a3a1ab2cd29665c98b4fa00672537a324" title="possible query types">QUERY_TYPE_SELECT</a>:
                        <a class="code" href="generate_8c.html#a90dce4f4c4ebd4d2f2a2bf5c2bbc45ed">virg_sql_genselect</a>(root-&gt;query.select, vm);
                        <span class="keywordflow">break</span>;
        }

        <span class="keywordflow">return</span> <a class="code" href="virginian_8h.html#ae39e133b80ee1958313531a94cb517d2" title="used to return a function success">VIRG_SUCCESS</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="a90dce4f4c4ebd4d2f2a2bf5c2bbc45ed"></a><!-- doxytag: member="generate.c::virg_sql_genselect" ref="a90dce4f4c4ebd4d2f2a2bf5c2bbc45ed" args="(node_select *root, virg_vm *vm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int virg_sql_genselect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structnode__select.html">node_select</a> *&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirg__vm.html">virg_vm</a> *&#160;</td>
          <td class="paramname"><em>vm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Generate a select statement. This function just calls all the passes in order, passing around the AST and a linked list of opcodes that we output to a virtual machine. </p>

<p>Definition at line <a class="el" href="generate_8c_source.html#l00795">795</a> of file <a class="el" href="generate_8c_source.html">generate.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <a class="code" href="generate_8c.html#a00cd55b38f9af2b9d72f76476779c3d5">select_columnpass</a>(root);
        <a class="code" href="structabsop.html" title="Abstracted virg_op structure with metadata used in code generation.">absop</a> *ops;
        <a class="code" href="generate_8c.html#a33ab7485e7a795df8225bd8defbfb5ef">select_resolveopspass</a>(root);
        <a class="code" href="generate_8c.html#ab02866ad29709e513f58d61ce1b8de82">select_structurepass</a>(root, &amp;ops);
        <a class="code" href="generate_8c.html#ac42c04f0256cd2b6bbc82047e4940e52">select_opplacepass</a>(ops);
        <a class="code" href="generate_8c.html#aeb76bd04e58b3b6f9852bff32bfcda38">select_registerpass</a>(ops);
        <a class="code" href="generate_8c.html#a2c845e0018d8773884873c4f42bd53b6">select_outputpass</a>(ops, vm);
        <a class="code" href="generate_8c.html#a303958079340768f839ccbb074ccaf6a">select_cleanuppass</a>(ops);

        <span class="keywordflow">return</span> <a class="code" href="virginian_8h.html#ae39e133b80ee1958313531a94cb517d2" title="used to return a function success">VIRG_SUCCESS</a>;
}
</pre></div>
</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Feb 15 2012 01:21:46 for Virginian by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
