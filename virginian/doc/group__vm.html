<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Virginian: Virtual Machine Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Virginian</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Virtual Machine Functions</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vm.html#ga73e734fd1c2210bd54c01fa03f84e949">virg_vm_addop</a> (<a class="el" href="structvirg__vm.html">virg_vm</a> *<a class="el" href="vm__gpu_8cu.html#a946d0d35b3bc20faef9b521a79e7e89a">vm</a>, int op, int p1, int p2, int p3, <a class="el" href="unionvirg__var.html">virg_var</a> p4)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an op to a virtual machine's statement.  <a href="#ga73e734fd1c2210bd54c01fa03f84e949"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vm.html#gae7f94c15491cb88fd9c2325222a40b2c">virg_vm_allocresult</a> (<a class="el" href="structvirginian.html">virginian</a> *v, <a class="el" href="structvirg__vm.html">virg_vm</a> *<a class="el" href="vm__gpu_8cu.html#a946d0d35b3bc20faef9b521a79e7e89a">vm</a>, <a class="el" href="structvirg__tablet__meta.html">virg_tablet_meta</a> **<a class="el" href="vm__gpu_8cu.html#a98365893b0ed61f342c55a901d47b738">meta</a>, <a class="el" href="structvirg__tablet__meta.html">virg_tablet_meta</a> *template_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and create a new result tablet or copy an existing tablet.  <a href="#gae7f94c15491cb88fd9c2325222a40b2c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vm.html#ga62ed45a3768fa86f06a144ddc52852aa">virg_vm_cleanup</a> (<a class="el" href="structvirginian.html">virginian</a> *v, <a class="el" href="structvirg__vm.html">virg_vm</a> *<a class="el" href="vm__gpu_8cu.html#a946d0d35b3bc20faef9b521a79e7e89a">vm</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Cleanup a virtual machine.  <a href="#ga62ed45a3768fa86f06a144ddc52852aa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vm.html#ga7112813a421bcf264ceae71555f18dce">virg_vm_execute</a> (<a class="el" href="structvirginian.html">virginian</a> *v, <a class="el" href="structvirg__vm.html">virg_vm</a> *<a class="el" href="vm__gpu_8cu.html#a946d0d35b3bc20faef9b521a79e7e89a">vm</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the virtual machine using its stored statement.  <a href="#ga7112813a421bcf264ceae71555f18dce"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vm.html#gaa7c1110ac7283aac8da00edc168d8252">virg_vm_freeresults</a> (<a class="el" href="structvirginian.html">virginian</a> *v, <a class="el" href="structvirg__vm.html">virg_vm</a> *<a class="el" href="vm__gpu_8cu.html#a946d0d35b3bc20faef9b521a79e7e89a">vm</a>)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a result tablet reader.  <a href="#gaa7c1110ac7283aac8da00edc168d8252"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvirg__vm.html">virg_vm</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vm.html#ga81b5ae6a1970758a5f3b62f3cabe5e95">virg_vm_init</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a virtual machine context.  <a href="#ga81b5ae6a1970758a5f3b62f3cabe5e95"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vm.html#ga5eaa0064c9e2b63ad19d7e3ea95da9c0">virginia_single</a> (<a class="el" href="structvirginian.html">virginian</a> *v, <a class="el" href="structvirg__vm.html">virg_vm</a> *<a class="el" href="vm__gpu_8cu.html#a946d0d35b3bc20faef9b521a79e7e89a">vm</a>, <a class="el" href="structvirg__tablet__meta.html">virg_tablet_meta</a> *tab, <a class="el" href="structvirg__tablet__meta.html">virg_tablet_meta</a> **res_, unsigned row, unsigned num_rows)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the data-parallel portion of an opcode program on a single core.  <a href="#ga5eaa0064c9e2b63ad19d7e3ea95da9c0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vm.html#gac8a59abde2076fa5dad105b0ec11cf5f">virginia_multi</a> (void *arg_)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the data-parallel portion of an opcode program on multiple cores.  <a href="#gac8a59abde2076fa5dad105b0ec11cf5f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vm.html#gaf37b1a607a52750691eb8de389837bd6">virg_vm_cpu</a> (<a class="el" href="structvirginian.html">virginian</a> *v, <a class="el" href="structvirg__vm.html">virg_vm</a> *<a class="el" href="vm__gpu_8cu.html#a946d0d35b3bc20faef9b521a79e7e89a">vm</a>, <a class="el" href="structvirg__tablet__meta.html">virg_tablet_meta</a> **tab, <a class="el" href="structvirg__tablet__meta.html">virg_tablet_meta</a> **res, unsigned num_tablets)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Chooses and prepares for execution on one or multiple CPU cores.  <a href="#gaf37b1a607a52750691eb8de389837bd6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__vm.html#ga0889e7b22f4c8280651cc5c89c2b29b7">virg_vm_gpu</a> (<a class="el" href="structvirginian.html">virginian</a> *v, <a class="el" href="structvirg__vm.html">virg_vm</a> *vm_, <a class="el" href="structvirg__tablet__meta.html">virg_tablet_meta</a> **tab, <a class="el" href="structvirg__tablet__meta.html">virg_tablet_meta</a> **res, unsigned num_tablets)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute the data-parallel portion of an opcode program on a GPU.  <a href="#ga0889e7b22f4c8280651cc5c89c2b29b7"></a><br/></td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga73e734fd1c2210bd54c01fa03f84e949"></a><!-- doxytag: member="addop.c::virg_vm_addop" ref="ga73e734fd1c2210bd54c01fa03f84e949" args="(virg_vm *vm, int op, int p1, int p2, int p3, virg_var p4)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int virg_vm_addop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvirg__vm.html">virg_vm</a> *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="unionvirg__var.html">virg_var</a>&#160;</td>
          <td class="paramname"><em>p4</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add an op to a virtual machine's statement. </p>
<p>Copies the arguments into the statement of the virtual machine as a new operation, incrementing the total number of operations.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>Pointer to the context struct of the virtual machine </td></tr>
    <tr><td class="paramname">op</td><td>The opcode of the new operation </td></tr>
    <tr><td class="paramname">p1</td><td>Argument 1 of the new operation </td></tr>
    <tr><td class="paramname">p2</td><td>Argument 2 of the new operation </td></tr>
    <tr><td class="paramname">p3</td><td>Argument 3 of the new operation </td></tr>
    <tr><td class="paramname">p4</td><td>Argument 4, the union argument, of the new operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>VIRG_SUCCESS or VIRG_FAIL depending on errors during the function call </dd></dl>

<p>Definition at line <a class="el" href="addop_8c_source.html#l00019">19</a> of file <a class="el" href="addop_8c_source.html">addop.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <a class="code" href="virginian_8h.html#a53c3d8f6ba6373cf9095d58d3ba4f7e1">VIRG_DEBUG_CHECK</a>(vm-&gt;<a class="code" href="structvirg__vm.html#a6b42b0c00d2be4bfdfa29404476dade6" title="number of opcodes in the opcode program">num_ops</a> + 1 &gt;= <a class="code" href="virginian_8h.html#a35812eb8ca48e1d30a7c7dd3b4797af4" title="maximum number of query statement opcodes allowed">VIRG_OPS</a>, <span class="stringliteral">&quot;Too many ops&quot;</span>)
        vm-&gt;stmt[vm-&gt;num_ops].op = op;
        vm-&gt;stmt[vm-&gt;num_ops].p1 = p1;
        vm-&gt;stmt[vm-&gt;num_ops].p2 = p2;
        vm-&gt;stmt[vm-&gt;num_ops].p3 = p3;
        vm-&gt;stmt[vm-&gt;num_ops].p4 = p4;
        vm-&gt;num_ops++;

        return <a class="code" href="virginian_8h.html#ae39e133b80ee1958313531a94cb517d2" title="used to return a function success">VIRG_SUCCESS</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gae7f94c15491cb88fd9c2325222a40b2c"></a><!-- doxytag: member="allocresult.c::virg_vm_allocresult" ref="gae7f94c15491cb88fd9c2325222a40b2c" args="(virginian *v, virg_vm *vm, virg_tablet_meta **meta, virg_tablet_meta *template_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int virg_vm_allocresult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvirginian.html">virginian</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirg__vm.html">virg_vm</a> *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirg__tablet__meta.html">virg_tablet_meta</a> **&#160;</td>
          <td class="paramname"><em>meta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirg__tablet__meta.html">virg_tablet_meta</a> *&#160;</td>
          <td class="paramname"><em>template_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Allocate and create a new result tablet or copy an existing tablet. </p>
<p>Creates a new result tablet for use with the passed virtual machine. If the template argument is NULL, then a completely new result tablet with default settings will be create, otherwise the template will be duplicated with minimal changes for the new tablet. This function also handles adding this tablet to the virtual machine's linked list of result tablets.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Pointer to the state struct of the database system </td></tr>
    <tr><td class="paramname">vm</td><td>Pointer to the context structure of the virtual machine </td></tr>
    <tr><td class="paramname">meta</td><td>Pointer to a tablet pointer through which the new tablet will be returned </td></tr>
    <tr><td class="paramname">template</td><td>Pointer to an existing result tablet, whose meta settings will be duplicated </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>VIRG_SUCCESS or VIRG_FAIL depending on errors during the function call </dd></dl>

<p>Definition at line <a class="el" href="allocresult_8c_source.html#l00022">22</a> of file <a class="el" href="allocresult_8c_source.html">allocresult.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a> *tab;

        <span class="comment">// get a new tablet slot using new id</span>
        <span class="keywordtype">unsigned</span> <span class="keywordtype">id</span> = v-&gt;<a class="code" href="structvirginian.html#a4475e39a0380efc27a50823d7fc11cb7" title="database file state">db</a>.<a class="code" href="structvirg__db.html#a6657ccb6b05ec1b98ff5d5e868f4e1bc" title="used to assign unique ids to each data and result tablet">tablet_id_counter</a>++;
        <a class="code" href="group__database.html#gaa6d6a3af446d22e836e0acc488db0348" title="Allocate a tablet slot and return a pointer to it.">virg_db_alloc</a>(v, &amp;tab, <span class="keywordtype">id</span>);

<span class="preprocessor">#ifdef VIRG_DEBUG</span>
<span class="preprocessor"></span>        memset((<span class="keywordtype">char</span>*)tab + <span class="keyword">sizeof</span>(<a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a>), 0xDEADBEEF,
                <a class="code" href="virginian_8h.html#a2ac1573feba851890134cec421e2e763" title="size of tablets, must be equal for the db file and the database">VIRG_TABLET_SIZE</a> - <span class="keyword">sizeof</span>(<a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a>));
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
        <span class="comment">// if we don&#39;t have a result tablet to copy set attributes to defaults</span>
        <span class="keywordflow">if</span>(template_ == NULL) {
                tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a21626738f2e3e000d376a912558130fa" title="variable type of the key column">key_type</a> = VIRG_INT;
                tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a16e649bf6f3217270c3fe84fe4d00114" title="stride of the variable type of the key column">key_stride</a> = virg_sizeof(VIRG_INT);
                tab-&gt;<a class="code" href="structvirg__tablet__meta.html#aba80db72f84483fc51af9e39fe5c3590" title="boolean indicating whether this is the last tablet in the tablet string">last_tablet</a> = 1;
                tab-&gt;<a class="code" href="structvirg__tablet__meta.html#aa7a96e05a26f25298bece2686c758200" title="stride of the key pointer variable type">key_pointer_stride</a> = <span class="keyword">sizeof</span>(size_t);
                tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a381166a5323a226a9cf70a527e9f7876" title="relative ptr to the beginning of the key column">key_block</a> = <span class="keyword">sizeof</span>(<a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a>);
                tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a785691ca2a53ec6a5d5c34bca74c882d" title="fixed-size rows that can be in this tablet without reorganizing columns">possible_rows</a> = 0;
                tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a9b5a18ab0b852cdcb0608d0113ce25f1" title="relative ptr to the beginning of the key pointer column">key_pointers_block</a> = tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a381166a5323a226a9cf70a527e9f7876" title="relative ptr to the beginning of the key column">key_block</a> +
                        tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a785691ca2a53ec6a5d5c34bca74c882d" title="fixed-size rows that can be in this tablet without reorganizing columns">possible_rows</a> * tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a16e649bf6f3217270c3fe84fe4d00114" title="stride of the variable type of the key column">key_stride</a>;
                tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a7b2629d1c97658c8b7a89dff95a1d52b" title="relative ptr to the beginning of the fixed-column area">fixed_block</a> = tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a9b5a18ab0b852cdcb0608d0113ce25f1" title="relative ptr to the beginning of the key pointer column">key_pointers_block</a> +
                        tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a785691ca2a53ec6a5d5c34bca74c882d" title="fixed-size rows that can be in this tablet without reorganizing columns">possible_rows</a> * tab-&gt;<a class="code" href="structvirg__tablet__meta.html#aa7a96e05a26f25298bece2686c758200" title="stride of the key pointer variable type">key_pointer_stride</a>;
                tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a3ec258f17124528e236512d3b30b74be" title="relative ptr to the beginning of the variable-sized data area">variable_block</a> = tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a7b2629d1c97658c8b7a89dff95a1d52b" title="relative ptr to the beginning of the fixed-column area">fixed_block</a>;
                tab-&gt;<a class="code" href="structvirg__tablet__meta.html#ad65a3feff0d4d970d956214bc658a962" title="total size of this tablet">size</a> = tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a3ec258f17124528e236512d3b30b74be" title="relative ptr to the beginning of the variable-sized data area">variable_block</a>;
                tab-&gt;<a class="code" href="structvirg__tablet__meta.html#ae0d98c019521326affbcab24362a7c71" title="stride of fixed-size columns, including key and key pointer">row_stride</a> = tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a16e649bf6f3217270c3fe84fe4d00114" title="stride of the variable type of the key column">key_stride</a> + tab-&gt;<a class="code" href="structvirg__tablet__meta.html#aa7a96e05a26f25298bece2686c758200" title="stride of the key pointer variable type">key_pointer_stride</a>;
                tab-&gt;<a class="code" href="structvirg__tablet__meta.html#aa3595a9a97105ce081422911c30c0269" title="number of fixed-size columns">fixed_columns</a> = 0;
                tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a5bd107899dc507b45e96fd2c020aa533" title="pointer to the disk info struct associated with this tablet">info</a> = NULL;
                tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a1059257e09da533e228e62e881a2c813" title="boolean indicating whether or not this tablet is part of a table">in_table</a> = 0;
        }
        <span class="comment">// otherwise copy everything from the previous result tablet and set only</span>
        <span class="comment">// what we need</span>
        <span class="keywordflow">else</span> {
                memcpy(tab, template_, <span class="keyword">sizeof</span>(<a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a>));
                <span class="keyword">template</span>_-&gt;last_tablet = 0;
                tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a8287e9d36017a86bc3657de07cfbb47e" title="tablet id">id</a> = id;
                <span class="keyword">template</span>_-&gt;next = tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a8287e9d36017a86bc3657de07cfbb47e" title="tablet id">id</a>;
        }

        tab-&gt;<a class="code" href="structvirg__tablet__meta.html#ac68b11acc7d264e16025e3017a3c671a" title="number of rows stored in this tablet">rows</a> = 0;
        tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a08bff8a2b2cbe7abbbdb0e85a530b065" title="id of the next tablet in the tablet string">next</a> = 0;

        <span class="comment">// allocate a new node for the linked list of results</span>
        <a class="code" href="structvirg__result__node__.html" title="Linked list node used to manage result tablets.">virg_result_node</a> *node = malloc(<span class="keyword">sizeof</span>(<a class="code" href="structvirg__result__node__.html" title="Linked list node used to manage result tablets.">virg_result_node</a>));
        <a class="code" href="virginian_8h.html#a5199c848f6c06c5aabdc6546774d4f0d" title="print an error and return failure if the condition is true">VIRG_CHECK</a>(node == NULL, <span class="stringliteral">&quot;Out of memory&quot;</span>)

        node-&gt;<span class="keywordtype">id</span> = <span class="keywordtype">id</span>;
        node-&gt;next = NULL;

        <span class="comment">// add newly allocated tablet to the end of the linked list</span>
        if(vm-&gt;head_result == NULL)
                vm-&gt;head_result = node;
        else
                vm-&gt;tail_result-&gt;next = node;
        vm-&gt;tail_result = node;
        
        <span class="comment">// return pointer to new result tablet</span>
        meta[0] = tab;

        return <a class="code" href="virginian_8h.html#ae39e133b80ee1958313531a94cb517d2" title="used to return a function success">VIRG_SUCCESS</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga62ed45a3768fa86f06a144ddc52852aa"></a><!-- doxytag: member="cleanup.c::virg_vm_cleanup" ref="ga62ed45a3768fa86f06a144ddc52852aa" args="(virginian *v, virg_vm *vm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void virg_vm_cleanup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvirginian.html">virginian</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirg__vm.html">virg_vm</a> *&#160;</td>
          <td class="paramname"><em>vm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Cleanup a virtual machine. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>Pointer to the context struct of the virtual machine </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>VIRG_SUCCESS or VIRG_FAIL depending on errors during the function call </dd></dl>

<p>Definition at line <a class="el" href="cleanup_8c_source.html#l00012">12</a> of file <a class="el" href="cleanup_8c_source.html">cleanup.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="keywordflow">if</span>(vm-&gt;<a class="code" href="structvirg__vm.html#adf14bd3fd58a91fa721b5c7ef3d5f9c5" title="pointer to the head node of the result tablet list">head_result</a> != NULL)
                <a class="code" href="group__vm.html#gaa7c1110ac7283aac8da00edc168d8252" title="Initialize a result tablet reader.">virg_vm_freeresults</a>(v, vm);

        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> i = 0; i &lt; vm-&gt;<a class="code" href="structvirg__vm.html#a6b42b0c00d2be4bfdfa29404476dade6" title="number of opcodes in the opcode program">num_ops</a>; i++)
                <span class="keywordflow">switch</span>(vm-&gt;<a class="code" href="structvirg__vm.html#aa1232e0a814aa339153059d9f86320ba" title="opcode program">stmt</a>[i].op) {
                        <span class="keywordflow">case</span> OP_ResultColumn :
                                free(vm-&gt;<a class="code" href="structvirg__vm.html#aa1232e0a814aa339153059d9f86320ba" title="opcode program">stmt</a>[i].p4.s);
                                <span class="keywordflow">break</span>;
                }

        free(vm);
}
</pre></div>
</div>
</div>
<a class="anchor" id="gaf37b1a607a52750691eb8de389837bd6"></a><!-- doxytag: member="vm_cpu.c::virg_vm_cpu" ref="gaf37b1a607a52750691eb8de389837bd6" args="(virginian *v, virg_vm *vm, virg_tablet_meta **tab, virg_tablet_meta **res, unsigned num_tablets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int virg_vm_cpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvirginian.html">virginian</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirg__vm.html">virg_vm</a> *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirg__tablet__meta.html">virg_tablet_meta</a> **&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirg__tablet__meta.html">virg_tablet_meta</a> **&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num_tablets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Chooses and prepares for execution on one or multiple CPU cores. </p>
<p>This function is intended to make the <a class="el" href="group__vm.html#ga7112813a421bcf264ceae71555f18dce" title="Execute the virtual machine using its stored statement.">virg_vm_execute()</a> function by making the choice between executing with a single or multiple CPU cores transparent based on the <a class="el" href="structvirginian.html#add73a147022b2ac21e84dcf50781a7f0" title="enables multicore">virginian.use_multi</a>. If this value is false, we loop and call virginia_single for every tablet to be processes. Otherwise, we create <a class="el" href="structvirginian.html#aa09161b8fdfc2f003a751bde3268677d" title="number of threads to use for multi-core cpu execution">virginian.multi_threads</a> threads which greedily process as many data tablets as they can and wait for them to finish before returning. If num_tablets is 0, then there is no restriction on how many data tablets will be processed in this function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Pointer to the state struct of the database system </td></tr>
    <tr><td class="paramname">vm</td><td>Pointer to the context struct of the virtual machine </td></tr>
    <tr><td class="paramname">tab</td><td>Pointer to the pointer to the current data tablet to process </td></tr>
    <tr><td class="paramname">res</td><td>Pointer to the pointer to the current result tablet </td></tr>
    <tr><td class="paramname">num_tablets</td><td>The number of tablets to process during this call, 0 for as many as possible </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>VIRG_SUCCESS or VIRG_FAIL depending on errors during the function call </dd></dl>

<p>Definition at line <a class="el" href="vm__cpu_8c_source.html#l00031">31</a> of file <a class="el" href="vm__cpu_8c_source.html">vm_cpu.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="keywordtype">unsigned</span> proced = 0;

        <span class="comment">// if the virginian struct is set to execute using only a single core</span>
        <span class="keywordflow">if</span>(!v-&gt;<a class="code" href="structvirginian.html#add73a147022b2ac21e84dcf50781a7f0" title="enables multicore">use_multi</a>) {
                <span class="comment">// infinite loop</span>
                <span class="keywordflow">while</span>(1) {
                        <span class="comment">// add an extra lock to the current data and result tablets that</span>
                        <span class="comment">// will be released at a lower level within virginia_single()</span>
                        <a class="code" href="group__tablet.html#gabd69b51cf1469c95d1574b1d53935391" title="Add a lock to a tablet.">virg_tablet_lock</a>(v, tab[0]-&gt;<span class="keywordtype">id</span>);
                        <a class="code" href="group__tablet.html#gabd69b51cf1469c95d1574b1d53935391" title="Add a lock to a tablet.">virg_tablet_lock</a>(v, res[0]-&gt;<span class="keywordtype">id</span>);

                        <span class="comment">// single core execution function</span>
                        <a class="code" href="group__vm.html#ga5eaa0064c9e2b63ad19d7e3ea95da9c0" title="Execute the data-parallel portion of an opcode program on a single core.">virginia_single</a>(v, vm, tab[0], res, 0, tab[0]-&gt;rows);

                        <span class="comment">// we&#39;ve processed another tablet</span>
                        proced++;

                        <span class="comment">// break out if we&#39;ve processed enough tablets</span>
                        <span class="keywordflow">if</span>((num_tablets != 0 &amp;&amp; proced &gt;= num_tablets) || tab[0]-&gt;last_tablet)
                                <span class="keywordflow">break</span>;

                        <span class="comment">// load the next data tablet</span>
                        <a class="code" href="group__database.html#ga78584f2bb7ca78e1cb87378929ce40f2" title="Advance a tablet pointer to the next tablet in its string of tablets.">virg_db_loadnext</a>(v, tab);
                }
        }
        <span class="keywordflow">else</span> {
                pthread_t thread[v-&gt;<a class="code" href="structvirginian.html#aa09161b8fdfc2f003a751bde3268677d" title="number of threads to use for multi-core cpu execution">multi_threads</a>];

                <span class="comment">// copy values into the argument structure that must be used with</span>
                <span class="comment">// pthread_create()</span>
                <a class="code" href="structvirg__vm__arg.html" title="Holds the arguments for the multicore GPU virtual machine.">virg_vm_arg</a> arg;
                arg.v = v;
                arg.vm = <a class="code" href="vm__gpu_8cu.html#a946d0d35b3bc20faef9b521a79e7e89a" title="GPU constant memory variable to hold the virtual machine execution context.">vm</a>;
                arg.tab = tab[0];
                arg.res = res[0];
                arg.row = 0;
                arg.num_rows = 0;
                arg.num_tablets = num_tablets;
                arg.tablets_proced = 0;

                <span class="comment">// mutexes for dealing with the current last tablet and result tablets</span>
                <a class="code" href="virginian_8h.html#a5199c848f6c06c5aabdc6546774d4f0d" title="print an error and return failure if the condition is true">VIRG_CHECK</a>(pthread_mutex_init(&amp;arg.tab_lock, NULL), <span class="stringliteral">&quot;Could not init mutex&quot;</span>)
                <a class="code" href="virginian_8h.html#a5199c848f6c06c5aabdc6546774d4f0d" title="print an error and return failure if the condition is true">VIRG_CHECK</a>(pthread_mutex_init(&amp;arg.res_lock, NULL), &quot;Could not init mutex&quot;)

                <span class="comment">// create tablet processing threads</span>
                <span class="keywordtype">unsigned</span> i;
                for(i = 0; i &lt; v-&gt;multi_threads; i++)
                        pthread_create(&amp;thread[i], NULL, <a class="code" href="group__vm.html#gac8a59abde2076fa5dad105b0ec11cf5f" title="Execute the data-parallel portion of an opcode program on multiple cores.">virginia_multi</a>, (<span class="keywordtype">void</span>*) &amp;arg);

                <span class="comment">// wait for all threads to run out of data to process and finish</span>
                for(i = 0; i &lt; v-&gt;multi_threads; i++)
                        pthread_join(thread[i], NULL);

                tab[0] = arg.tab;
                res[0] = arg.res;

                <a class="code" href="virginian_8h.html#a5199c848f6c06c5aabdc6546774d4f0d" title="print an error and return failure if the condition is true">VIRG_CHECK</a>(pthread_mutex_destroy(&amp;arg.res_lock), &quot;Could not destroy mutex&quot;)
                <a class="code" href="virginian_8h.html#a5199c848f6c06c5aabdc6546774d4f0d" title="print an error and return failure if the condition is true">VIRG_CHECK</a>(pthread_mutex_destroy(&amp;arg.tab_lock), &quot;Could not destroy mutex&quot;)
        }
        
        return <a class="code" href="virginian_8h.html#ae39e133b80ee1958313531a94cb517d2" title="used to return a function success">VIRG_SUCCESS</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga7112813a421bcf264ceae71555f18dce"></a><!-- doxytag: member="execute.c::virg_vm_execute" ref="ga7112813a421bcf264ceae71555f18dce" args="(virginian *v, virg_vm *vm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int virg_vm_execute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvirginian.html">virginian</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirg__vm.html">virg_vm</a> *&#160;</td>
          <td class="paramname"><em>vm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Execute the virtual machine using its stored statement. </p>
<p>Execute the opcodes that have been stored in the passed virtual machine struct, choosing the execution location based on the options set in the virginian struct. This function executes the top-level opcodes that must be handled serially. Like the CPU virtual machine, this function uses a jump table to access code blocks with opcodes, rather than a switch statement. The jump table is simply an array of label addresses that is accessed using the integer value of each opcode, then jumped to with a goto. This function is also responsible for fetching the first data tablet of each loaded table and allocating the first result tablet, then releasing the final locks on the data and result tablet pointers at the end of the query, probably after the pointers have been altered by the lower-level execution functions. <a class="el" href="group__vm.html#ga0889e7b22f4c8280651cc5c89c2b29b7" title="Execute the data-parallel portion of an opcode program on a GPU.">virg_vm_gpu()</a> or <a class="el" href="group__vm.html#gaf37b1a607a52750691eb8de389837bd6" title="Chooses and prepares for execution on one or multiple CPU cores.">virg_vm_cpu()</a> is chosen based on the options in the virginian struct, and there is currently no capability to handle both simultaneously, as this would probably involve a more complex threading system.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Pointer to the state struct of the database system </td></tr>
    <tr><td class="paramname">vm</td><td>Pointer to the context struct of the virtual machine </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>VIRG_SUCCESS or VIRG_FAIL depending on errors during the function call </dd></dl>

<p>Definition at line <a class="el" href="execute_8c_source.html#l00028">28</a> of file <a class="el" href="execute_8c_source.html">execute.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="comment">// label jump table</span>
        <span class="keyword">static</span> <span class="keywordtype">void</span> *jump[] = { &amp;&amp;op_Table, &amp;&amp;op_ResultColumn, &amp;&amp;op_Parallel, &amp;&amp;op_Finish,
                &amp;&amp;NOP, &amp;&amp;NOP, &amp;&amp;NOP, &amp;&amp;NOP, &amp;&amp;NOP, &amp;&amp;NOP, &amp;&amp;NOP, &amp;&amp;NOP, &amp;&amp;NOP, &amp;&amp;NOP,
                &amp;&amp;NOP, &amp;&amp;NOP, &amp;&amp;NOP, &amp;&amp;NOP, &amp;&amp;NOP, &amp;&amp;NOP, &amp;&amp;NOP, &amp;&amp;NOP, &amp;&amp;NOP, &amp;&amp;NOP,
                &amp;&amp;NOP };

        <span class="keywordtype">int</span> p1, p2, p3;
        <a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a> *tab, *res;

        vm-&gt;<a class="code" href="structvirg__vm.html#acdad9572b2e3a5cdb6766c0cdc8c4b66" title="number of table handles used">num_tables</a> = 0;
        vm-&gt;<a class="code" href="structvirg__vm.html#a58a76075e1de12dc9959753f38fb37bc" title="high-level program counter">pc</a> = 0;
        vm-&gt;<a class="code" href="structvirg__vm.html#adf14bd3fd58a91fa721b5c7ef3d5f9c5" title="pointer to the head node of the result tablet list">head_result</a> = NULL;

        <span class="comment">// get a new result tablet</span>
        <a class="code" href="group__vm.html#gae7f94c15491cb88fd9c2325222a40b2c" title="Allocate and create a new result tablet or copy an existing tablet.">virg_vm_allocresult</a>(v, vm, &amp;res, NULL);

next:
        <span class="comment">// load the first 3 arguments automatically for convenience</span>
        p1 = vm-&gt;<a class="code" href="structvirg__vm.html#aa1232e0a814aa339153059d9f86320ba" title="opcode program">stmt</a>[vm-&gt;<a class="code" href="structvirg__vm.html#a58a76075e1de12dc9959753f38fb37bc" title="high-level program counter">pc</a>].p1;
        p2 = vm-&gt;<a class="code" href="structvirg__vm.html#aa1232e0a814aa339153059d9f86320ba" title="opcode program">stmt</a>[vm-&gt;<a class="code" href="structvirg__vm.html#a58a76075e1de12dc9959753f38fb37bc" title="high-level program counter">pc</a>].p2;
        p3 = vm-&gt;<a class="code" href="structvirg__vm.html#aa1232e0a814aa339153059d9f86320ba" title="opcode program">stmt</a>[vm-&gt;<a class="code" href="structvirg__vm.html#a58a76075e1de12dc9959753f38fb37bc" title="high-level program counter">pc</a>].p3;

<span class="preprocessor">#ifdef VIRG_DEBUG</span>
<span class="preprocessor"></span>        <span class="comment">// print the op and its arguments</span>
        <span class="comment">//fprintf(stderr, &quot;&lt;OP&gt;  %-*s%*i%*i%*i\n&quot;, 14,</span>
        <span class="comment">//      virg_opstring(vm-&gt;stmt[vm-&gt;pc].op), 5, p1, 5, p2, 5, p3);</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
        <span class="comment">// jump to the label in the jump table indexed with the integer value of the</span>
        <span class="comment">// current opcode</span>
        <span class="keywordflow">goto</span> *jump[vm-&gt;<a class="code" href="structvirg__vm.html#aa1232e0a814aa339153059d9f86320ba" title="opcode program">stmt</a>[vm-&gt;<a class="code" href="structvirg__vm.html#a58a76075e1de12dc9959753f38fb37bc" title="high-level program counter">pc</a>].op];

op_Table:
        <span class="comment">// check that we haven&#39;t loaded too many tables</span>
        assert(vm-&gt;<a class="code" href="structvirg__vm.html#acdad9572b2e3a5cdb6766c0cdc8c4b66" title="number of table handles used">num_tables</a> &lt; <a class="code" href="virginian_8h.html#ae435eb27cbf4eb64670ab0b8bf44db98" title="maximum number of tables to read from supported in vm">VIRG_VM_TABLES</a>);
        <span class="comment">// load the table into the first available table slot</span>
        vm-&gt;<a class="code" href="structvirg__vm.html#a9d320ceb01e5010039abdb14a800615e" title="table handles used for the query">table</a>[vm-&gt;<a class="code" href="structvirg__vm.html#acdad9572b2e3a5cdb6766c0cdc8c4b66" title="number of table handles used">num_tables</a>++] = p1;
        <span class="comment">// get a lock on the first tablet of the loaded table</span>
        <a class="code" href="group__database.html#ga45ebb12f5cd1cb668f06dcc64fd815a0" title="Load a tablet into a slot based on its ID and return a pointer.">virg_db_load</a>(v, v-&gt;<a class="code" href="structvirginian.html#a4475e39a0380efc27a50823d7fc11cb7" title="database file state">db</a>.<a class="code" href="structvirg__db.html#a1e3f0138b4b0b6b9e631fae4dad9f7a1" title="maps table id to the id of its first tablet">first_tablet</a>[p1], &amp;tab);
        vm-&gt;<a class="code" href="structvirg__vm.html#a58a76075e1de12dc9959753f38fb37bc" title="high-level program counter">pc</a>++;
        <span class="keywordflow">goto</span> next;

op_ResultColumn: <span class="comment">// type</span>
        <a class="code" href="group__tablet.html#gad8e8dfe554d09257dbccd44b7bc35f2c" title="Add a column to a tablet.">virg_tablet_addcolumn</a>(res, vm-&gt;<a class="code" href="structvirg__vm.html#aa1232e0a814aa339153059d9f86320ba" title="opcode program">stmt</a>[vm-&gt;<a class="code" href="structvirg__vm.html#a58a76075e1de12dc9959753f38fb37bc" title="high-level program counter">pc</a>].p4.s, (<a class="code" href="virginian_8h.html#a5edb977d9e195d5df43f1757f311292b" title="enumeration of all variable types used by the database">virg_t</a>)p1);
        vm-&gt;<a class="code" href="structvirg__vm.html#a58a76075e1de12dc9959753f38fb37bc" title="high-level program counter">pc</a>++;
        <span class="keywordflow">goto</span> next;

op_Parallel:
        <span class="comment">// make the result tablet as large as possible given the columns that have</span>
        <span class="comment">// been added to it</span>
        <a class="code" href="group__tablet.html#ga91abf3ca31d24bdc6be4b30ca0840d03" title="Maximize the fixed-size block of the tablet.">virg_tablet_addmaxrows</a>(v, res);
        <span class="comment">// start the data parallel section on the next opcode</span>
        vm-&gt;<a class="code" href="structvirg__vm.html#a58a76075e1de12dc9959753f38fb37bc" title="high-level program counter">pc</a>++;
        <span class="comment">// choose the execution location based on the properties of the virginian</span>
        <span class="comment">// state struct</span>
        <span class="keywordflow">if</span>(v-&gt;<a class="code" href="structvirginian.html#ae93e73cfddaddff800b4d6e11204c8a7" title="enables gpu execution">use_gpu</a>)
                <a class="code" href="group__vm.html#ga0889e7b22f4c8280651cc5c89c2b29b7" title="Execute the data-parallel portion of an opcode program on a GPU.">virg_vm_gpu</a>(v, vm, &amp;tab, &amp;res, 0);
        <span class="keywordflow">else</span>
                <a class="code" href="group__vm.html#gaf37b1a607a52750691eb8de389837bd6" title="Chooses and prepares for execution on one or multiple CPU cores.">virg_vm_cpu</a>(v, vm, &amp;tab, &amp;res, 0);
        vm-&gt;<a class="code" href="structvirg__vm.html#a58a76075e1de12dc9959753f38fb37bc" title="high-level program counter">pc</a> = p3;
        <span class="keywordflow">goto</span> next;

op_Finish:
        <span class="comment">// unlock our hold on the current data and result tablets</span>
        <a class="code" href="group__tablet.html#ga8e6a3f46a4efe9347c8202acc032db69" title="Release a lock to a tablet.">virg_tablet_unlock</a>(v, tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a8287e9d36017a86bc3657de07cfbb47e" title="tablet id">id</a>);
        <a class="code" href="group__tablet.html#ga8e6a3f46a4efe9347c8202acc032db69" title="Release a lock to a tablet.">virg_tablet_unlock</a>(v, res-&gt;<a class="code" href="structvirg__tablet__meta.html#a8287e9d36017a86bc3657de07cfbb47e" title="tablet id">id</a>);
        <span class="keywordflow">return</span> <a class="code" href="virginian_8h.html#ae39e133b80ee1958313531a94cb517d2" title="used to return a function success">VIRG_SUCCESS</a>;

<span class="comment">// opcode problem that resulted in a weird pc</span>
NOP:
        fprintf(stderr, <span class="stringliteral">&quot;Invalid OP\n&quot;</span>);
        <span class="keywordflow">return</span> <a class="code" href="virginian_8h.html#ac21dbbc06d2c74731554f359edd10702" title="used to return a function failure">VIRG_FAIL</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="gaa7c1110ac7283aac8da00edc168d8252"></a><!-- doxytag: member="freeresults.c::virg_vm_freeresults" ref="gaa7c1110ac7283aac8da00edc168d8252" args="(virginian *v, virg_vm *vm)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int virg_vm_freeresults </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvirginian.html">virginian</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirg__vm.html">virg_vm</a> *&#160;</td>
          <td class="paramname"><em>vm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize a result tablet reader. </p>
<p>Initialize a reader object to traverse the results of a query, given its virtual machine state struct. This should only be called with a <a class="el" href="structvirg__vm.html" title="State struct of the virtual machine context.">virg_vm</a> struct once a query that output results is run.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Pointer to the state struct of the database system </td></tr>
    <tr><td class="paramname">vm</td><td>Pointer to the context struct of the virtual machine </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>VIRG_SUCCESS or VIRG_FAIL depending on errors during the function call </dd></dl>

<p>Definition at line <a class="el" href="freeresults_8c_source.html#l00017">17</a> of file <a class="el" href="freeresults_8c_source.html">freeresults.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="comment">// pointers for walking the list</span>
        <a class="code" href="structvirg__result__node__.html" title="Linked list node used to manage result tablets.">virg_result_node</a> *node = vm-&gt;<a class="code" href="structvirg__vm.html#adf14bd3fd58a91fa721b5c7ef3d5f9c5" title="pointer to the head node of the result tablet list">head_result</a>;
        <a class="code" href="structvirg__result__node__.html" title="Linked list node used to manage result tablets.">virg_result_node</a> *next;

        <span class="keywordflow">while</span>(node != NULL) {
<span class="preprocessor">#ifdef VIRG_DEBUG</span>
<span class="preprocessor"></span>                <span class="keywordtype">unsigned</span> i;
                <span class="keywordtype">unsigned</span> taken = 0;
                <span class="keywordflow">for</span>(i = 0; i &lt; <a class="code" href="virginian_8h.html#a9c6e6ed866369d7cc0288fafd223a87b" title="tablet slots to allocate in memory">VIRG_MEM_TABLETS</a>; i++)
                        <span class="keywordflow">if</span>(v-&gt;<a class="code" href="structvirginian.html#ae6776e19e678dca8d07646de4ad8ae8c" title="use status of the tablet slot, 0 for unused, 1 for used, &gt;1 for each lock">tablet_slot_status</a>[i])
                                taken++;
                assert(taken == v-&gt;<a class="code" href="structvirginian.html#ab4ab09cb712e32031e114b442c0c8157" title="number of tablet slots which are unused">tablet_slots_taken</a>);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>                <span class="comment">// delete the result tablet from its slot</span>
                <a class="code" href="group__tablet.html#ga00875121a2be660a42c7633b13d0e27c" title="Deletes a tablet from memory and disk.">virg_tablet_remove</a>(v, node-&gt;<a class="code" href="structvirg__result__node__.html#a9bc7e6a0a08061ee5ae2130c22e55fe4" title="tablet id">id</a>);

                <span class="comment">// free the current node and move to the next</span>
                next = node-&gt;<a class="code" href="structvirg__result__node__.html#ae2440fb4659d404f8ff57e4306e69b29" title="pointer to the next node of the linked list">next</a>;
                free(node);
                node = next;
        }

        vm-&gt;<a class="code" href="structvirg__vm.html#adf14bd3fd58a91fa721b5c7ef3d5f9c5" title="pointer to the head node of the result tablet list">head_result</a> = NULL;
        vm-&gt;<a class="code" href="structvirg__vm.html#ae73ae2d846b279bc522b56c37b048978" title="pointer to the tail node of the result tablet list">tail_result</a> = NULL;

        <span class="keywordflow">return</span> <a class="code" href="virginian_8h.html#ae39e133b80ee1958313531a94cb517d2" title="used to return a function success">VIRG_SUCCESS</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga0889e7b22f4c8280651cc5c89c2b29b7"></a><!-- doxytag: member="vm_gpu.cu::virg_vm_gpu" ref="ga0889e7b22f4c8280651cc5c89c2b29b7" args="(virginian *v, virg_vm *vm_, virg_tablet_meta **tab, virg_tablet_meta **res, unsigned num_tablets)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int virg_vm_gpu </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvirginian.html">virginian</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirg__vm.html">virg_vm</a> *&#160;</td>
          <td class="paramname"><em>vm_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirg__tablet__meta.html">virg_tablet_meta</a> **&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirg__tablet__meta.html">virg_tablet_meta</a> **&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num_tablets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Execute the data-parallel portion of an opcode program on a GPU. </p>
<p>This function handles setting up and launching the virtual machine kernel that executes the virtual machine on the GPU. The user has a choice between serial kernel executions for each tablet, streaming executions with overlapping memcpys, and mapped execution, which is currently the fastest option.</p>
<p>If streaming and memory mapping are both disabled in the virginian struct, then kernels will be processed on the GPU serially. This means that the data tablet will be transferred to GPU memory, the virtual machine executed, then the result tablet transferred back for each tablet with no overlap. This is the slowest method of GPU execution, and it does not require pinned memory.</p>
<p>If streaming is enabled, regardless of the mapped memory setting, then it is used. This works by allocating a fixed number of tablet streams, set equal to half of the number of allocated GPU tablet slots, and overlapping data transfer, kernel execution, and result transfer for tablets. Each stream gets a data and result tablet slot on the GPU, and the loop iterates through each stream in a round-robin fashion executing virtual machines on tablets. Note that when we loop back and re-use streams then we block to wait for execution if the previous asynchronous launches. On Tesla C1060 hardware you cannot overlap transfers to the GPU with transfers from it, and thus streaming is about as fast as serial execution. Also note that on this hardware the semantics for asynchronous operations are somewhat frusterating. Based on informal tests, it appears that even though asynchronous operations are completely asynchronous with respect to the calling thread, the order in which they are added to streams has an effect on when they are run. Thus, there are non-optimal orderings of memory copies and kernel executions when multiple asynchronous operations are queued in multiple streams. Even with smarter ordering, however, the inability of current hardware to transfer both ways across the PCI bus simultaneously means that this method of execution is currently only useful if either the data or results of a query are resident in GPU memory for the entire processing operation. For some reason I could only create 6 streams at a time during my testing, so you may encounter problems if you allocate more than 12 gpu tablet slots.</p>
<p>Mapped memory is currently the fastest method for GPU processing by far. It is also much simpler, since we have fewer memory copies and we don't have to manage multiple streams at the same time. The tablet row counter is implemented as a separate variable for mapped memory, since it would be very very expensive to perform atomic operations on a mapped location.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Pointer to the state struct of the database system </td></tr>
    <tr><td class="paramname">vm</td><td>Pointer to the context struct of the virtual machine </td></tr>
    <tr><td class="paramname">tab</td><td>Pointer to the pointer to the current data tablet to process </td></tr>
    <tr><td class="paramname">res</td><td>Pointer to the pointer to the current result tablet </td></tr>
    <tr><td class="paramname">num_tablets</td><td>Number of tablets to process on the GPU, 0 if as many as possible </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>VIRG_SUCCESS or VIRG_FAIL depending on errors during the function call </dd></dl>

<p>Definition at line <a class="el" href="vm__gpu_8cu_source.html#l00107">107</a> of file <a class="el" href="vm__gpu_8cu_source.html">vm_gpu.cu</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="keywordtype">unsigned</span> proced = 0;
        <span class="comment">//num_tablets = 5;</span>

        <a class="code" href="virginian_8h.html#a5199c848f6c06c5aabdc6546774d4f0d" title="print an error and return failure if the condition is true">VIRG_CHECK</a>(v-&gt;<a class="code" href="structvirginian.html#a2820593ec616cb2093cabb74e7affa5e" title="threads per block for gpu execution">threads_per_block</a> != <a class="code" href="virginian_8h.html#a924b9ad484637fcf22848b33d0e41663" title="cuda threads per block">VIRG_THREADSPERBLOCK</a>,
                <span class="stringliteral">&quot;Cannot change compile-time threads per block&quot;</span>);
        <a class="code" href="virginian_8h.html#a5199c848f6c06c5aabdc6546774d4f0d" title="print an error and return failure if the condition is true">VIRG_CHECK</a>(v-&gt;<a class="code" href="structvirginian.html#a2820593ec616cb2093cabb74e7affa5e" title="threads per block for gpu execution">threads_per_block</a> == v-&gt;<a class="code" href="structvirginian.html#a2820593ec616cb2093cabb74e7affa5e" title="threads per block for gpu execution">threads_per_block</a> &amp; 0xFFFFFFC0,
                <span class="stringliteral">&quot;Threads per block must be a multiple of 64&quot;</span>);

        <span class="comment">// execute GPU kernels in serial with no overlapping memory copies</span>
        <span class="keywordflow">if</span>(v-&gt;<a class="code" href="structvirginian.html#af361324ce5a460bc8e54b6ccde5c5c47" title="enables stream execution">use_stream</a> == 0 &amp;&amp; v-&gt;<a class="code" href="structvirginian.html#aa3e6f75167f32ecdadd72f330f4b5a31" title="enables mapped execution, only used if stream is false">use_mmap</a> == 0)
        {
                <span class="comment">// copy virtual machine context to constant memory</span>
                cudaMemcpyToSymbol((<span class="keywordtype">char</span>*)&amp;<a class="code" href="vm__gpu_8cu.html#a946d0d35b3bc20faef9b521a79e7e89a" title="GPU constant memory variable to hold the virtual machine execution context.">vm</a>, (<span class="keywordtype">char</span>*)vm_,
                        <span class="keyword">sizeof</span>(<a class="code" href="structvirg__vm.html" title="State struct of the virtual machine context.">virg_vm</a>), 0, cudaMemcpyHostToDevice);
                <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;serial const memcpy 1&quot;</span>);

                <span class="comment">// copy result meta information to constant memory</span>
                <span class="comment">// we only need to do this once for multiple kernel calls because the</span>
                <span class="comment">// information about the column spacing is identical between all result</span>
                <span class="comment">// tablets</span>
                cudaMemcpyToSymbol((<span class="keywordtype">char</span>*)&amp;<a class="code" href="vm__gpu_8cu.html#a98365893b0ed61f342c55a901d47b738">meta</a>, (<span class="keywordtype">char</span>*)res[0],
                        <span class="keyword">sizeof</span>(<a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a>), <span class="keyword">sizeof</span>(<a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a>),
                        cudaMemcpyHostToDevice);
                <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;serial const memcpy 2&quot;</span>);

                <span class="keywordtype">void</span> *tab_slot = v-&gt;<a class="code" href="structvirginian.html#a8cf3b95984dce9135f5937237bdabdb8" title="pointer to the beginning of the allocated gpu tablet slots">gpu_slots</a>;
                <span class="keywordtype">void</span> *res_slot = (<span class="keywordtype">char</span>*)v-&gt;<a class="code" href="structvirginian.html#a8cf3b95984dce9135f5937237bdabdb8" title="pointer to the beginning of the allocated gpu tablet slots">gpu_slots</a> + <a class="code" href="virginian_8h.html#a2ac1573feba851890134cec421e2e763" title="size of tablets, must be equal for the db file and the database">VIRG_TABLET_SIZE</a>;

                <span class="comment">// create timers</span>
                cudaEvent_t start, data, kernel, results;
                cudaEventCreate(&amp;start);
                cudaEventCreate(&amp;data);
                cudaEventCreate(&amp;kernel);
                cudaEventCreate(&amp;results);
                vm_-&gt;timing1 = 0;
                vm_-&gt;timing2 = 0;
                vm_-&gt;timing3 = 0;

                <span class="keywordflow">while</span>(1) {
                        <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;const clear&quot;</span>);

                        <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;before serial const 2 memcpy&quot;</span>);
                        <span class="comment">// copy data tablet meta information to constant memory</span>
                        cudaMemcpyToSymbol((<span class="keywordtype">char</span>*)&amp;meta, (<span class="keywordtype">char</span>*)tab[0],
                                <span class="keyword">sizeof</span>(<a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a>), 0, cudaMemcpyHostToDevice);
                        <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;serial const 2 memcpy&quot;</span>);

                        <span class="comment">// round threadblocks up given number of rows to process and threads</span>
                        <span class="comment">// per block</span>
                        <span class="keywordtype">unsigned</span> rows = tab[0]-&gt;rows;
                        <span class="keywordtype">int</span> blocks = (rows + v-&gt;<a class="code" href="structvirginian.html#a2820593ec616cb2093cabb74e7affa5e" title="threads per block for gpu execution">threads_per_block</a> - 1) /
                                v-&gt;<a class="code" href="structvirginian.html#a2820593ec616cb2093cabb74e7affa5e" title="threads per block for gpu execution">threads_per_block</a>;
                        assert(blocks &lt; 65536);

                        <span class="comment">// start timer</span>
                        cudaEventRecord(start, 0);

                        <span class="comment">// copy entire data tablet to GPU memory</span>
                        cudaMemcpy(tab_slot, (<span class="keywordtype">char</span>*)tab[0],
                                tab[0]-&gt;size, cudaMemcpyHostToDevice);
                        <span class="comment">// copy res meta information to GPU memory, where the rows element</span>
                        <span class="comment">// will be updated as result rows are output</span>
                        cudaMemcpy(res_slot, (<span class="keywordtype">char</span>*)res[0],
                                <span class="keyword">sizeof</span>(<a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a>), cudaMemcpyHostToDevice);
                        <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;data memcpy&quot;</span>);

<span class="preprocessor">#ifdef VIRG_DEBUG</span>
<span class="preprocessor"></span>                        cudaMemset((<span class="keywordtype">char</span>*)res_slot + <span class="keyword">sizeof</span>(<a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a>),
                                0xDEADBEEF, <a class="code" href="virginian_8h.html#a2ac1573feba851890134cec421e2e763" title="size of tablets, must be equal for the db file and the database">VIRG_TABLET_SIZE</a> - <span class="keyword">sizeof</span>(<a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a>));
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
                        <span class="comment">// record we&#39;re done with data transfer</span>
                        cudaEventRecord(data, 0);

                        virg_timer_start();

                        <span class="comment">// kernel launch</span>
                        <span class="keywordtype">void</span>* tab_arg = v-&gt;<a class="code" href="structvirginian.html#a8cf3b95984dce9135f5937237bdabdb8" title="pointer to the beginning of the allocated gpu tablet slots">gpu_slots</a>;
                        <span class="keywordtype">void</span>* res_arg = (<span class="keywordtype">char</span>*)v-&gt;<a class="code" href="structvirginian.html#a8cf3b95984dce9135f5937237bdabdb8" title="pointer to the beginning of the allocated gpu tablet slots">gpu_slots</a> + <a class="code" href="virginian_8h.html#a2ac1573feba851890134cec421e2e763" title="size of tablets, must be equal for the db file and the database">VIRG_TABLET_SIZE</a>;

                        virginia_gpu&lt;&lt;&lt;blocks, v-&gt;<a class="code" href="structvirginian.html#a2820593ec616cb2093cabb74e7affa5e" title="threads per block for gpu execution">threads_per_block</a>&gt;&gt;&gt;
                                (0, 1, tab_arg, res_arg, 0, 0, NULL);
        cudaDeviceSynchronize();

                        <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;Single kernel launch&quot;</span>);

                        <span class="comment">// record we&#39;re done with the kernel call</span>
                        cudaEventRecord(kernel, 0);

                        <span class="comment">// transfer result tablet back from GPU memory</span>
                        cudaMemcpy((<span class="keywordtype">char</span>*)res[0], res_slot,
                                <a class="code" href="virginian_8h.html#a2ac1573feba851890134cec421e2e763" title="size of tablets, must be equal for the db file and the database">VIRG_TABLET_SIZE</a>, cudaMemcpyDeviceToHost);

                        <span class="comment">//virg_print_tablet_meta(res[0]);</span>

                        <span class="comment">// record we&#39;re done with the results transfer</span>
                        cudaEventRecord(results, 0);

                        <span class="comment">// output timing results for this tablet</span>
                        <span class="keywordtype">float</span> f[3];
                        cudaEventElapsedTime(&amp;f[0], start, data);
                        cudaEventElapsedTime(&amp;f[1], data, kernel);
                        cudaEventSynchronize(results);
                        cudaEventElapsedTime(&amp;f[2], kernel, results);
                        <span class="comment">//fprintf(stderr, &quot;serial block %u: %f %f %f %f\n&quot;, proced, cum, f[0], f[1], f[2]);</span>
                        vm_-&gt;timing1 += f[0];
                        vm_-&gt;timing2 += f[1];
                        vm_-&gt;timing3 += f[2];

                        proced++;

                        <span class="comment">// if we&#39;ve processed enough tablets exit the loop</span>
                        <span class="keywordflow">if</span>(tab[0]-&gt;last_tablet || (num_tablets != 0 &amp;&amp; proced &gt;= num_tablets))
                                <span class="keywordflow">break</span>;

                        <span class="comment">// load next data tablet</span>
                        <a class="code" href="group__database.html#ga78584f2bb7ca78e1cb87378929ce40f2" title="Advance a tablet pointer to the next tablet in its string of tablets.">virg_db_loadnext</a>(v, tab);
                        <span class="comment">// if this tablet has no rows, break from this loop</span>
                        <span class="comment">// this occurs when a new data tablet is created during an insert</span>
                        <span class="comment">// operation but no rows have been added to it yet</span>
                        <span class="keywordflow">if</span>(tab[0]-&gt;rows == 0)
                                <span class="keywordflow">break</span>;

                        <span class="comment">// safely allocate next result tablet</span>
                        <a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a> *temp = res[0];
                        <a class="code" href="group__vm.html#gae7f94c15491cb88fd9c2325222a40b2c" title="Allocate and create a new result tablet or copy an existing tablet.">virg_vm_allocresult</a>(v, vm_, res, res[0]);
                        <a class="code" href="group__tablet.html#ga8e6a3f46a4efe9347c8202acc032db69" title="Release a lock to a tablet.">virg_tablet_unlock</a>(v, temp-&gt;<a class="code" href="structvirg__tablet__meta.html#a8287e9d36017a86bc3657de07cfbb47e" title="tablet id">id</a>);
                }

                vm_-&gt;timing1 /= 1000;
                vm_-&gt;timing2 /= 1000;
                vm_-&gt;timing3 /= 1000;

                <span class="comment">// destruct timers</span>
                cudaEventDestroy(start);
                cudaEventDestroy(data);
                cudaEventDestroy(kernel);
                cudaEventDestroy(results);
        }
        <span class="comment">// if the streaming functionality is turned on</span>
        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(v-&gt;<a class="code" href="structvirginian.html#af361324ce5a460bc8e54b6ccde5c5c47" title="enables stream execution">use_stream</a>)
        {
                <span class="comment">// copy virtual machine context to GPU constant memory</span>
                cudaMemcpyToSymbol((<span class="keywordtype">char</span>*)&amp;vm, (<span class="keywordtype">char</span>*)vm_,
                        <span class="keyword">sizeof</span>(<a class="code" href="structvirg__vm.html" title="State struct of the virtual machine context.">virg_vm</a>), 0, cudaMemcpyHostToDevice);
                <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;const memcpy&quot;</span>);

                <span class="comment">// we should always have an even number of tablets</span>
                assert(<a class="code" href="virginian_8h.html#a55a19fc1029cc2d13cddfa8e0b9077b1" title="tablet slots to allocate in gpu memory">VIRG_GPU_TABLETS</a> % 2 == 0);
                <span class="keywordtype">unsigned</span> stream_width = <a class="code" href="virginian_8h.html#a55a19fc1029cc2d13cddfa8e0b9077b1" title="tablet slots to allocate in gpu memory">VIRG_GPU_TABLETS</a> / 2;
                cudaStream_t stream[stream_width];
                <span class="keywordtype">unsigned</span> slot_ids[stream_width];
                <span class="keywordtype">int</span> slot_wait = 0;
                <span class="keywordtype">unsigned</span> i;

                <span class="comment">// construct streams </span>
                <span class="keywordflow">for</span>(i = 0; i &lt; stream_width; i++)
                        cudaStreamCreate(&amp;stream[i]);
                <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;stream create&quot;</span>);

                <span class="comment">// create timers for each stream independently</span>
                cudaEvent_t ev_create[stream_width], ev_start[stream_width],
                                ev_data[stream_width], ev_kernel[stream_width],
                                ev_results[stream_width];
                <span class="keywordflow">for</span>(i = 0; i &lt; stream_width; i++) {
                        cudaEventCreate(&amp;ev_create[i]);
                        cudaEventCreate(&amp;ev_start[i]);
                        cudaEventCreate(&amp;ev_data[i]);
                        cudaEventCreate(&amp;ev_kernel[i]);
                        cudaEventCreate(&amp;ev_results[i]);
                }

                <span class="comment">// start timer for each stream</span>
                <span class="keywordflow">for</span>(i = 0; i &lt; stream_width; i++)
                        cudaEventRecord(ev_create[i], stream[i]);

                <span class="comment">// process tablets until finished</span>
                <span class="keywordflow">for</span>(i = 0; 1; i++) {
                        <span class="comment">// if every stream has been used, go back to use the first stream</span>
                        <span class="comment">// again</span>
                        <span class="keywordflow">if</span>(i &gt;= stream_width) {
                                i = 0;
                                slot_wait = 1;
                        }

                        <span class="comment">// if we are re-using streams then we need to block until they are</span>
                        <span class="comment">// actually finished</span>
                        <span class="keywordflow">if</span>(slot_wait) {
                                <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;before stream synchronize&quot;</span>);
                                <span class="comment">// block</span>
                                cudaStreamSynchronize(stream[i]);
                                <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;stream synchronize&quot;</span>);
                                <span class="comment">// unlock the tablets that the stream was using</span>
                                <a class="code" href="group__tablet.html#ga8e6a3f46a4efe9347c8202acc032db69" title="Release a lock to a tablet.">virg_tablet_unlock</a>(v, slot_ids[i * 2]);
                                <a class="code" href="group__tablet.html#ga8e6a3f46a4efe9347c8202acc032db69" title="Release a lock to a tablet.">virg_tablet_unlock</a>(v, slot_ids[i * 2 + 1]);

                                <span class="comment">// record processing completion and output times</span>
                                cudaEventSynchronize(ev_results[i]);
                                <span class="keywordtype">float</span> f[4];
                                cudaEventElapsedTime(&amp;f[0], ev_create[i], ev_start[i]);
                                cudaEventElapsedTime(&amp;f[1], ev_start[i], ev_data[i]);
                                cudaEventElapsedTime(&amp;f[2], ev_data[i], ev_kernel[i]);
                                cudaEventElapsedTime(&amp;f[3], ev_kernel[i], ev_results[i]);
                                fprintf(stderr, <span class="stringliteral">&quot;stream %u: %f %f %f %f\n&quot;</span>, i, f[0], f[1], f[2], f[3]);
                        }

                        <span class="comment">// if the data tablet doesn&#39;t have any rows then we&#39;re finished</span>
                        <span class="keywordflow">if</span>(tab[0]-&gt;rows == 0) {
                                proced++;
                                slot_ids[i * 2] = tab[0]-&gt;id;
                                slot_ids[i * 2 + 1] = res[0]-&gt;id;
                                <span class="keywordflow">break</span>;
                        }

<span class="preprocessor">#ifdef VIRG_DEBUG</span>
<span class="preprocessor"></span>                        <a class="code" href="group__tablet.html#ga63806dc508073da387d045837f0d7e9d" title="Ensure that the tablet is internally consistent and conforms to expectation.">virg_tablet_check</a>(tab[0]);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
                        <span class="comment">// round up blocks given rows to process and threads per block  </span>
                        <span class="keywordtype">int</span> blocks = (tab[0]-&gt;rows + v-&gt;<a class="code" href="structvirginian.html#a2820593ec616cb2093cabb74e7affa5e" title="threads per block for gpu execution">threads_per_block</a> - 1) / v-&gt;<a class="code" href="structvirginian.html#a2820593ec616cb2093cabb74e7affa5e" title="threads per block for gpu execution">threads_per_block</a>;
                        assert(blocks &lt; 65536);

                        <a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a> *temp_tab, *temp_res;

                        <span class="comment">// if there are still tablets to process load, otherwise don&#39;t</span>
                        <span class="comment">// note that we don&#39;t exit here because we need to wait for the</span>
                        <span class="comment">// other streams to finish</span>
                        <span class="keywordflow">if</span>(!tab[0]-&gt;last_tablet &amp;&amp; !(num_tablets != 0 &amp;&amp; proced + 1 &gt; num_tablets)) {
                                <a class="code" href="group__database.html#ga45ebb12f5cd1cb668f06dcc64fd815a0" title="Load a tablet into a slot based on its ID and return a pointer.">virg_db_load</a>(v, tab[0]-&gt;next, &amp;temp_tab);
                                <a class="code" href="group__vm.html#gae7f94c15491cb88fd9c2325222a40b2c" title="Allocate and create a new result tablet or copy an existing tablet.">virg_vm_allocresult</a>(v, vm_, &amp;temp_res, res[0]);
                        }

                        <span class="comment">// start timer for this stream</span>
                        cudaEventRecord(ev_start[i], stream[i]);

                        <span class="comment">// start tablet memcpy for this stream</span>
                        cudaMemcpyAsync((<span class="keywordtype">char</span>*)v-&gt;<a class="code" href="structvirginian.html#a8cf3b95984dce9135f5937237bdabdb8" title="pointer to the beginning of the allocated gpu tablet slots">gpu_slots</a> + (i * 2) * <a class="code" href="virginian_8h.html#a2ac1573feba851890134cec421e2e763" title="size of tablets, must be equal for the db file and the database">VIRG_TABLET_SIZE</a>,
                                (<span class="keywordtype">char</span>*)tab[0], tab[0]-&gt;size, cudaMemcpyHostToDevice, stream[i]);
                        <span class="comment">//virg_print_tablet_meta(tab[0]);</span>
                        <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;tab memcpy&quot;</span>);

                        <span class="comment">// start tablet meta to constant memory memcpy for this stream</span>
                        cudaMemcpyToSymbolAsync((<span class="keywordtype">char</span>*)&amp;meta, (<span class="keywordtype">char</span>*)tab[0],
                                <span class="keyword">sizeof</span>(<a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a>), i * 2 * <span class="keyword">sizeof</span>(<a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a>),
                                cudaMemcpyHostToDevice, stream[i]);
                        <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;tab meta&quot;</span>);

                        <span class="comment">// if we haven&#39;t put the result meta information in this stream&#39;s</span>
                        <span class="comment">// constant memory area yet</span>
                        <span class="keywordflow">if</span>(!slot_wait) {
                                <span class="comment">// copy result meta information for this stream</span>
                                cudaMemcpyToSymbolAsync((<span class="keywordtype">char</span>*)&amp;meta, (<span class="keywordtype">char</span>*)res[0],
                                        <span class="keyword">sizeof</span>(<a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a>), (i * 2 + 1) * <span class="keyword">sizeof</span>(<a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a>),
                                        cudaMemcpyHostToDevice, stream[i]);
                                <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;res meta&quot;</span>);
                        }

                        <span class="comment">// copy meta information to global memory as well so that the rows</span>
                        <span class="comment">// variable can be updated during query execution</span>
                        cudaMemcpyAsync((<span class="keywordtype">char</span>*)v-&gt;<a class="code" href="structvirginian.html#a8cf3b95984dce9135f5937237bdabdb8" title="pointer to the beginning of the allocated gpu tablet slots">gpu_slots</a> + (i * 2 + 1) * <a class="code" href="virginian_8h.html#a2ac1573feba851890134cec421e2e763" title="size of tablets, must be equal for the db file and the database">VIRG_TABLET_SIZE</a>,
                                (<span class="keywordtype">char</span>*)res[0], <span class="keyword">sizeof</span>(<a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a>), cudaMemcpyHostToDevice, stream[i]);
                        <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;res setup memcpy&quot;</span>);

                        <span class="comment">// record we&#39;re done with data transfer for this stream</span>
                        cudaEventRecord(ev_data[i], stream[i]);

                        <span class="comment">// launch the kernel for this stream</span>
                        <span class="keywordtype">void</span> *tab_arg = (<span class="keywordtype">char</span>*)v-&gt;<a class="code" href="structvirginian.html#a8cf3b95984dce9135f5937237bdabdb8" title="pointer to the beginning of the allocated gpu tablet slots">gpu_slots</a> + (i * 2) * <a class="code" href="virginian_8h.html#a2ac1573feba851890134cec421e2e763" title="size of tablets, must be equal for the db file and the database">VIRG_TABLET_SIZE</a>;
                        <span class="keywordtype">void</span> *res_arg = (<span class="keywordtype">char</span>*)v-&gt;<a class="code" href="structvirginian.html#a8cf3b95984dce9135f5937237bdabdb8" title="pointer to the beginning of the allocated gpu tablet slots">gpu_slots</a> + (i * 2 + 1) * <a class="code" href="virginian_8h.html#a2ac1573feba851890134cec421e2e763" title="size of tablets, must be equal for the db file and the database">VIRG_TABLET_SIZE</a>;
                        virginia_gpu&lt;&lt;&lt;blocks, v-&gt;<a class="code" href="structvirginian.html#a2820593ec616cb2093cabb74e7affa5e" title="threads per block for gpu execution">threads_per_block</a>, 0, stream[i]&gt;&gt;&gt;
                                (i * 2, i * 2 + 1, tab_arg, res_arg, 0, 0, NULL);
                        <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;kernel&quot;</span>);

                        <span class="comment">// record that the kernel execution has finished</span>
                        cudaEventRecord(ev_kernel[i], stream[i]);

                        <span class="comment">// copy result tablet back for this stream</span>
                        cudaMemcpyAsync((<span class="keywordtype">char</span>*)res[0], (<span class="keywordtype">char</span>*)v-&gt;<a class="code" href="structvirginian.html#a8cf3b95984dce9135f5937237bdabdb8" title="pointer to the beginning of the allocated gpu tablet slots">gpu_slots</a> + (i * 2 + 1) * <a class="code" href="virginian_8h.html#a2ac1573feba851890134cec421e2e763" title="size of tablets, must be equal for the db file and the database">VIRG_TABLET_SIZE</a>,
                                <a class="code" href="virginian_8h.html#a2ac1573feba851890134cec421e2e763" title="size of tablets, must be equal for the db file and the database">VIRG_TABLET_SIZE</a>, cudaMemcpyDeviceToHost, stream[i]);
                        <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;res memcpy&quot;</span>);

                        <span class="comment">// record that we&#39;re done with the result transfer for this stream</span>
                        cudaEventRecord(ev_results[i], stream[i]);

                        <span class="comment">// store the current data and result tablet pointers in the stream&#39;s</span>
                        <span class="comment">// slot</span>
                        proced++;
                        slot_ids[i * 2] = tab[0]-&gt;id;
                        slot_ids[i * 2 + 1] = res[0]-&gt;id;

                        <span class="comment">// check if we&#39;ve processed enough tablets</span>
                        <span class="keywordflow">if</span>(tab[0]-&gt;last_tablet || (num_tablets != 0 &amp;&amp; proced &gt;= num_tablets))
                                <span class="keywordflow">break</span>;

                        tab[0] = temp_tab;
                        res[0] = temp_res;
                }

                i++;

                <span class="keywordtype">unsigned</span> j;
                <span class="keywordflow">if</span>(!slot_wait)
                        i = 0;
                <span class="comment">// for each unfinished stream</span>
                <span class="keywordflow">for</span>(j = 0; j &lt; <a class="code" href="virginian_8h.html#ac8c9f6fbeb9d60a07ec61b3f3430d48a" title="convenience macro to return the min of the two inputs">VIRG_MIN</a>(stream_width, proced); j++, i++) {
                        <span class="keywordflow">if</span>(i &gt;= stream_width)
                                i = 0;

                        <span class="comment">// wait for the stream to finish and print timing information</span>
                        cudaStreamSynchronize(stream[i]);
                        cudaEventSynchronize(ev_results[i]);
                        <span class="keywordtype">float</span> f[4];
                        cudaEventElapsedTime(&amp;f[0], ev_create[i], ev_start[i]);
                        cudaEventElapsedTime(&amp;f[1], ev_start[i], ev_data[i]);
                        cudaEventElapsedTime(&amp;f[2], ev_data[i], ev_kernel[i]);
                        cudaEventElapsedTime(&amp;f[3], ev_kernel[i], ev_results[i]);
                        <span class="comment">//fprintf(stderr, &quot;stream %u: %f %f %f %f\n&quot;, i, f[0], f[1], f[2], f[3]);</span>

                        <span class="comment">// leave last data and result tablets locked</span>
                        <span class="keywordflow">if</span>(j &lt; stream_width - 1 &amp;&amp; j &lt; proced - 1) {
                                <a class="code" href="group__tablet.html#ga8e6a3f46a4efe9347c8202acc032db69" title="Release a lock to a tablet.">virg_tablet_unlock</a>(v, slot_ids[i * 2]);
                                <a class="code" href="group__tablet.html#ga8e6a3f46a4efe9347c8202acc032db69" title="Release a lock to a tablet.">virg_tablet_unlock</a>(v, slot_ids[i * 2 + 1]);
                        }
                }

                <span class="comment">// destruct timers and streams</span>
                <span class="keywordflow">for</span>(i = 0; i &lt; stream_width; i++) {
                        cudaEventDestroy(ev_create[i]);
                        cudaEventDestroy(ev_start[i]);
                        cudaEventDestroy(ev_data[i]);
                        cudaEventDestroy(ev_kernel[i]);
                        cudaEventDestroy(ev_results[i]);
                        cudaStreamDestroy(stream[i]);
                }
        }
        <span class="comment">// memory mapped kernel execution</span>
        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(v-&gt;<a class="code" href="structvirginian.html#aa3e6f75167f32ecdadd72f330f4b5a31" title="enables mapped execution, only used if stream is false">use_mmap</a>)
        {
                assert(<a class="code" href="virginian_8h.html#a55a19fc1029cc2d13cddfa8e0b9077b1" title="tablet slots to allocate in gpu memory">VIRG_GPU_TABLETS</a> &gt;= 2);
<span class="preprocessor">#ifdef VIRG_NOPINNED</span>
<span class="preprocessor"></span>                <a class="code" href="virginian_8h.html#a5199c848f6c06c5aabdc6546774d4f0d" title="print an error and return failure if the condition is true">VIRG_CHECK</a>(1, <span class="stringliteral">&quot;cannot use mapped execution without pinned memory&quot;</span>);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
                <span class="comment">// copy virtual machine context into gpu constant memory</span>
                cudaMemcpyToSymbol((<span class="keywordtype">char</span>*)&amp;vm, (<span class="keywordtype">char</span>*)vm_,
                        <span class="keyword">sizeof</span>(<a class="code" href="structvirg__vm.html" title="State struct of the virtual machine context.">virg_vm</a>), 0, cudaMemcpyHostToDevice);
                <span class="comment">// copy result tablet meta data into gpu constant memory</span>
                <span class="comment">// this needs to be done only once since the column sizes etc don&#39;t</span>
                <span class="comment">// change</span>
                cudaMemcpyToSymbol((<span class="keywordtype">char</span>*)&amp;meta, (<span class="keywordtype">char</span>*)res[0],
                        <span class="keyword">sizeof</span>(<a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a>), <span class="keyword">sizeof</span>(<a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a>), cudaMemcpyHostToDevice);
                <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;mapped const memcpy&quot;</span>);

                cudaMemcpyToSymbol((<span class="keywordtype">char</span>*)&amp;meta, (<span class="keywordtype">char</span>*)tab[0],
                        <span class="keyword">sizeof</span>(<a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a>), 0, cudaMemcpyHostToDevice);
                <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;mapped const 2 memcpy&quot;</span>);

                <span class="comment">// construct timers</span>
                cudaEvent_t start, data, kernel, results;
                cudaEventCreate(&amp;start);
                cudaEventCreate(&amp;data);
                cudaEventCreate(&amp;kernel);
                cudaEventCreate(&amp;results);
                <span class="keywordtype">float</span> cum = 0;

                <span class="keywordflow">while</span>(1) {
                        <span class="comment">// start timer</span>
                        cudaEventRecord(start, 0);

                        <span class="comment">//virg_print_tablet_meta(tab[0]);</span>

                        <span class="comment">//fprintf(stderr, &quot;::::%u\n&quot;, sizeof(virg_tablet_meta));</span>

                        <span class="comment">// copy tablet meta information to gpu constant memory</span>
                        <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;before const 2 memcpy&quot;</span>);
                        cudaMemcpyToSymbol((<span class="keywordtype">char</span>*)&amp;meta, (<span class="keywordtype">char</span>*)tab[0],
                                <span class="keyword">sizeof</span>(<a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a>), 0, cudaMemcpyHostToDevice);
                        <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;const 2 memcpy&quot;</span>);

                        <span class="comment">// round number of thread blocks up given the number of rows to</span>
                        <span class="comment">// process and the threads per block</span>
                        <span class="keywordtype">unsigned</span> rows = tab[0]-&gt;rows;
                        <span class="keywordtype">int</span> blocks = (rows + v-&gt;<a class="code" href="structvirginian.html#a2820593ec616cb2093cabb74e7affa5e" title="threads per block for gpu execution">threads_per_block</a> - 1) / v-&gt;<a class="code" href="structvirginian.html#a2820593ec616cb2093cabb74e7affa5e" title="threads per block for gpu execution">threads_per_block</a>;
                        assert(blocks &lt; 65536);

                        <span class="keywordtype">unsigned</span> zero = 0;
                        <span class="comment">// copy 0 into the result row counter</span>
                        cudaMemcpyToSymbol((<span class="keywordtype">char</span>*)&amp;<a class="code" href="vm__gpu_8cu.html#a95d1e761c77556e272c886c2a4d6f9f2" title="total number of result rows output during mapped memory vm execution">row_counter</a>, (<span class="keywordtype">char</span>*)&amp;zero,
                                <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>), 0, cudaMemcpyHostToDevice);
                        <span class="comment">// copy 0 into the result row buffer counter</span>
                        cudaMemcpyToSymbol((<span class="keywordtype">char</span>*)&amp;<a class="code" href="vm__gpu_8cu.html#a87536ff8892e0b19a11ba0225f23ebae" title="total number of result rows that have reached global memory">rowbuff_counter</a>, (<span class="keywordtype">char</span>*)&amp;zero,
                                <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>), 0, cudaMemcpyHostToDevice);
                        cudaMemcpyToSymbol((<span class="keywordtype">char</span>*)&amp;<a class="code" href="vm__gpu_8cu.html#ab0eca051cf092db5512eb335a15785aa" title="counter incremented by threadblocks when they write">threadblock_order</a>, (<span class="keywordtype">char</span>*)&amp;zero,
                                <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>), 0, cudaMemcpyHostToDevice);
                        cudaMemset((<span class="keywordtype">char</span>*)v-&gt;<a class="code" href="structvirginian.html#a8cf3b95984dce9135f5937237bdabdb8" title="pointer to the beginning of the allocated gpu tablet slots">gpu_slots</a> + <a class="code" href="virginian_8h.html#a2ac1573feba851890134cec421e2e763" title="size of tablets, must be equal for the db file and the database">VIRG_TABLET_SIZE</a>, 0,
                                <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>) * blocks);
                        <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;row_counter set&quot;</span>);

                        <span class="comment">// record that we&#39;re done transferring data</span>
                        <span class="comment">// since we&#39;re using mapped memory this is negligible since we just</span>
                        <span class="comment">// need to set constant memory and 2 variables</span>
                        cudaEventRecord(data, 0);

                        <span class="comment">// get gpu pointers to the data and result tablets in main memory</span>
                        <span class="keywordtype">void</span> *tab_arg;
                        <span class="keywordtype">void</span> *res_arg;
                        cudaHostGetDevicePointer(&amp;tab_arg, tab[0], 0);
                        <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;get tab device ptr&quot;</span>);
                        cudaHostGetDevicePointer(&amp;res_arg, res[0], 0);
                        <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;get res device ptr&quot;</span>);

                        <span class="comment">// launch kernel using mapped pointers</span>
                        virginia_gpu&lt;&lt;&lt;blocks, v-&gt;<a class="code" href="structvirginian.html#a2820593ec616cb2093cabb74e7affa5e" title="threads per block for gpu execution">threads_per_block</a>&gt;&gt;&gt;
                                (0, 1, tab_arg, res_arg, 0, 0, v-&gt;<a class="code" href="structvirginian.html#a8cf3b95984dce9135f5937237bdabdb8" title="pointer to the beginning of the allocated gpu tablet slots">gpu_slots</a>);
                        <a class="code" href="virginian_8h.html#a1d1644a2595d5c074a86067bfa7ddd4a" title="return failure and print it if there is an outstanding cuda error">VIRG_CUDCHK</a>(<span class="stringliteral">&quot;Single mapped kernel launch&quot;</span>);

                        <span class="comment">// record we&#39;re done with the kernel call</span>
                        cudaEventRecord(kernel, 0);

                        <span class="comment">// copy the number of tablet result rows from gpu memory</span>
                        cudaMemcpyFromSymbol((<span class="keywordtype">char</span>*)&amp;res[0]-&gt;rows, (<span class="keywordtype">char</span>*)&amp;row_counter,
                                <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span>), 0, cudaMemcpyDeviceToHost);

                        <span class="comment">// record that we&#39;re done transferring results information</span>
                        <span class="comment">// this should also be negligible</span>
                        cudaEventRecord(results, 0);

                        <span class="comment">// get timing results</span>
                        <span class="keywordtype">float</span> f[3];
                        cudaEventElapsedTime(&amp;f[0], start, data);
                        cudaEventElapsedTime(&amp;f[1], data, kernel);
                        cudaEventSynchronize(results);
                        cudaEventElapsedTime(&amp;f[2], kernel, results);

                        <span class="comment">// print timing information</span>
                        <span class="comment">//fprintf(stderr, &quot;block %u: %f %f %f %f\n&quot;, proced, cum, f[0], f[1], f[2]);</span>
                        
                        <span class="comment">// add to cumulative time</span>
                        cum += f[0] + f[1] + f[2];

                        proced++;

                        <span class="comment">// check if we&#39;re done processing tablets</span>
                        <span class="keywordflow">if</span>(tab[0]-&gt;last_tablet || (num_tablets != 0 &amp;&amp; proced &gt;= num_tablets))
                                <span class="keywordflow">break</span>;

                        <span class="comment">// load next data tablet</span>
                        <a class="code" href="group__database.html#ga78584f2bb7ca78e1cb87378929ce40f2" title="Advance a tablet pointer to the next tablet in its string of tablets.">virg_db_loadnext</a>(v, tab);

                        <span class="comment">// if this data tablet has no rows, finish</span>
                        <span class="keywordflow">if</span>(tab[0]-&gt;rows == 0)
                                <span class="keywordflow">break</span>;

                        <a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a> *temp = res[0];
                        <a class="code" href="group__vm.html#gae7f94c15491cb88fd9c2325222a40b2c" title="Allocate and create a new result tablet or copy an existing tablet.">virg_vm_allocresult</a>(v, vm_, res, res[0]);
                        <a class="code" href="group__tablet.html#ga8e6a3f46a4efe9347c8202acc032db69" title="Release a lock to a tablet.">virg_tablet_unlock</a>(v, temp-&gt;<a class="code" href="structvirg__tablet__meta.html#a8287e9d36017a86bc3657de07cfbb47e" title="tablet id">id</a>);
                }

                <span class="comment">// destruct timers</span>
                cudaEventDestroy(start);
                cudaEventDestroy(data);
                cudaEventDestroy(kernel);
                cudaEventDestroy(results);
        }

        <span class="comment">// wait for all cuda operations to finish</span>
        cudaDeviceSynchronize();

        <span class="keywordflow">return</span> <a class="code" href="virginian_8h.html#ae39e133b80ee1958313531a94cb517d2" title="used to return a function success">VIRG_SUCCESS</a>;
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga81b5ae6a1970758a5f3b62f3cabe5e95"></a><!-- doxytag: member="init.c::virg_vm_init" ref="ga81b5ae6a1970758a5f3b62f3cabe5e95" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvirg__vm.html">virg_vm</a>* virg_vm_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize a virtual machine context. </p>
<p>Allocates and sets the default values of a virtual machine context</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">vm</td><td>Pointer to the context struct of the virtual machine </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>VIRG_SUCCESS or VIRG_FAIL depending on errors during the function call </dd></dl>

<p>Definition at line <a class="el" href="vm_2init_8c_source.html#l00013">13</a> of file <a class="el" href="vm_2init_8c_source.html">init.c</a>.</p>
<div class="fragment"><pre class="fragment">{
    <a class="code" href="structvirg__vm.html" title="State struct of the virtual machine context.">virg_vm</a> *<a class="code" href="vm__gpu_8cu.html#a946d0d35b3bc20faef9b521a79e7e89a" title="GPU constant memory variable to hold the virtual machine execution context.">vm</a> = (<a class="code" href="structvirg__vm.html" title="State struct of the virtual machine context.">virg_vm</a>*)malloc(<span class="keyword">sizeof</span>(<a class="code" href="structvirg__vm.html" title="State struct of the virtual machine context.">virg_vm</a>));

        memset(vm, 0xDEADBEEF, <span class="keyword">sizeof</span>(<a class="code" href="structvirg__vm.html" title="State struct of the virtual machine context.">virg_vm</a>));

        vm-&gt;<a class="code" href="structvirg__vm.html#a58a76075e1de12dc9959753f38fb37bc" title="high-level program counter">pc</a> = 0;
        vm-&gt;<a class="code" href="structvirg__vm.html#adf14bd3fd58a91fa721b5c7ef3d5f9c5" title="pointer to the head node of the result tablet list">head_result</a> = NULL;
    vm-&gt;<a class="code" href="structvirg__vm.html#a6b42b0c00d2be4bfdfa29404476dade6" title="number of opcodes in the opcode program">num_ops</a> = 0;
    vm-&gt;<a class="code" href="structvirg__vm.html#acdad9572b2e3a5cdb6766c0cdc8c4b66" title="number of table handles used">num_tables</a> = 0;
    <span class="keywordflow">return</span> <a class="code" href="vm__gpu_8cu.html#a946d0d35b3bc20faef9b521a79e7e89a" title="GPU constant memory variable to hold the virtual machine execution context.">vm</a>;
}    
</pre></div>
</div>
</div>
<a class="anchor" id="gac8a59abde2076fa5dad105b0ec11cf5f"></a><!-- doxytag: member="virginia.c::virginia_multi" ref="gac8a59abde2076fa5dad105b0ec11cf5f" args="(void *arg_)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* virginia_multi </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Execute the data-parallel portion of an opcode program on multiple cores. </p>
<p>This function is called by pthread_create() to run as an independent thread, which greedily processes data until there is none left. The multi-core version includes mutexes to protect accesses to data and result tablets.</p>
<p>Like <a class="el" href="group__vm.html#ga7112813a421bcf264ceae71555f18dce" title="Execute the virtual machine using its stored statement.">virg_vm_execute()</a>, <a class="el" href="group__vm.html#ga5eaa0064c9e2b63ad19d7e3ea95da9c0" title="Execute the data-parallel portion of an opcode program on a single core.">virginia_single()</a> and <a class="el" href="group__vm.html#gac8a59abde2076fa5dad105b0ec11cf5f" title="Execute the data-parallel portion of an opcode program on multiple cores.">virginia_multi()</a> use a jump table rather than a switch to access the code for each opcode. This is accomplished with an array of label addresses, which is accessed with the value of each opcode, then jumped to with a goto.</p>
<p>The CPU virtual machine is written with tight inner loops to process blocks of rows at the same time, which we'll call a SIMD block. Since both cells in a column, and cells in a SIMD virtual machine register are stored adjacent to each other, this allows for efficient cache locality and direct memcpy operations.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>A struct containing all of the arguments for this function </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>VIRG_SUCCESS or VIRG_FAIL depending on errors during the function call </dd></dl>

<p><p>This multi-core version assigns data to process in a greedy way. If the thread is just starting or if the all its data has been processed, it locks the tablet pointer and gets a new block, or entire tablet to process, then updates this pointer. Thus, all threads execute until the data runs out and they are never idle</p>
<p>All threads share a result tablet and lock a mutex on it to get a block on the tablet where they can place their result rows.</p>
<p>Outputting result rows is done through memcpy operations, and we make an effort to minimize the number of these calls. Thus, for every register being output, we loop over every one of the SIMD rows (which are adjacent in memory) and lazily perform a copy only when we encounter a row that will not be output to the result block.</p>
</p>

<p>Definition at line <a class="el" href="virginia_8c_source.html#l00263">263</a> of file <a class="el" href="virginia_8c_source.html">virginia.c</a>.</p>
<div class="fragment"><pre class="fragment">{
        <span class="comment">// unpack arguments from the passed struct</span>
        <a class="code" href="structvirg__vm__arg.html" title="Holds the arguments for the multicore GPU virtual machine.">virg_vm_arg</a> *arg = (<a class="code" href="structvirg__vm__arg.html" title="Holds the arguments for the multicore GPU virtual machine.">virg_vm_arg</a>*) arg_;
        <a class="code" href="structvirginian.html" title="State struct of the whole database.">virginian</a> *v = arg-&gt;v;
        <a class="code" href="structvirg__vm.html" title="State struct of the virtual machine context.">virg_vm</a> *<a class="code" href="vm__gpu_8cu.html#a946d0d35b3bc20faef9b521a79e7e89a" title="GPU constant memory variable to hold the virtual machine execution context.">vm</a> = arg-&gt;vm;
        <a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a> *tab = NULL;
        <a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a> **res_ = &amp;arg-&gt;res;
        <span class="keywordtype">unsigned</span> row;
        <span class="keywordtype">unsigned</span> num_rows = arg-&gt;num_rows;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
        <a class="code" href="structvirg__tablet__meta.html" title="Tablet meta information.">virg_tablet_meta</a> *res = res_[0];

        <a class="code" href="structvirg__vm__simdcontext.html" title="Lower-level data parallel CPU virtual machine context.">virg_vm_simdcontext</a> context;
        <span class="keywordtype">unsigned</span> i;
        <span class="keywordtype">int</span> j;
        <span class="keywordtype">int</span> p1 = 0, p2 = 0, p3 = 0;
        <span class="keywordtype">void</span> *ptr1, *ptr2;
        <span class="keywordtype">int</span> valid[<a class="code" href="virginian_8h.html#a6b039207848380e774147e035d3876c0" title="number of rows to process on the cpu in a block">VIRG_CPU_SIMD</a>];
        <span class="keywordtype">unsigned</span> last_row;
        <span class="keywordtype">unsigned</span> simd_rows;
        <span class="keywordtype">unsigned</span> total_valid;

        <span class="comment">// jump table for opcodes handled in this function</span>
        <span class="keyword">static</span> <span class="keywordtype">void</span> *jump[] = { &amp;&amp;NOP, &amp;&amp;NOP, &amp;&amp;NOP, &amp;&amp;NOP,
                &amp;&amp;op_Column, &amp;&amp;op_Rowid, &amp;&amp;op_Result, &amp;&amp;op_Converge, &amp;&amp;op_Invalid, &amp;&amp;op_Cast,
                &amp;&amp;op_Integer, &amp;&amp;op_Float, &amp;&amp;op_Le, &amp;&amp;op_Lt, &amp;&amp;op_Ge, &amp;&amp;op_Gt, &amp;&amp;op_Eq,
                &amp;&amp;op_Neq, &amp;&amp;op_Add, &amp;&amp;op_Sub, &amp;&amp;op_Mul, &amp;&amp;op_Div, &amp;&amp;op_And, &amp;&amp;op_Or,
                &amp;&amp;op_Not };

<span class="preprocessor">#ifdef __MULTI</span>
<span class="preprocessor"></span>        <a class="code" href="group__tablet.html#gabd69b51cf1469c95d1574b1d53935391" title="Add a lock to a tablet.">virg_tablet_lock</a>(v, res-&gt;<a class="code" href="structvirg__tablet__meta.html#a8287e9d36017a86bc3657de07cfbb47e" title="tablet id">id</a>);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
        <span class="keywordflow">while</span>(1) {
<span class="preprocessor">#ifdef __MULTI </span>
<span class="preprocessor"></span><span class="comment">                /**</span>
<span class="comment">                 * This multi-core version assigns data to process in a greedy way. If</span>
<span class="comment">                 * the thread is just starting or if the all its data has been</span>
<span class="comment">                 * processed, it locks the tablet pointer and gets a new block, or</span>
<span class="comment">                 * entire tablet to process, then updates this pointer. Thus, all</span>
<span class="comment">                 * threads execute until the data runs out and they are never idle</span>
<span class="comment">                 */</span>
                pthread_mutex_lock(&amp;arg-&gt;tab_lock);
                <span class="comment">// if the current row position is at the end of the current tablet</span>
                <span class="keywordflow">if</span>(arg-&gt;row &gt;= arg-&gt;tab-&gt;<a class="code" href="structvirg__tablet__meta.html#ac68b11acc7d264e16025e3017a3c671a" title="number of rows stored in this tablet">rows</a>) {
                        <span class="comment">// if this is the last tablet</span>
                        <span class="keywordflow">if</span>(arg-&gt;tab-&gt;<a class="code" href="structvirg__tablet__meta.html#aba80db72f84483fc51af9e39fe5c3590" title="boolean indicating whether this is the last tablet in the tablet string">last_tablet</a>) {
                                <span class="comment">// unlock data and result tablets and exit</span>
                                pthread_mutex_unlock(&amp;arg-&gt;tab_lock);
                                <span class="keywordflow">if</span>(tab != NULL)
                                        <a class="code" href="group__tablet.html#ga8e6a3f46a4efe9347c8202acc032db69" title="Release a lock to a tablet.">virg_tablet_unlock</a>(v, tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a8287e9d36017a86bc3657de07cfbb47e" title="tablet id">id</a>);
                                <a class="code" href="group__tablet.html#ga8e6a3f46a4efe9347c8202acc032db69" title="Release a lock to a tablet.">virg_tablet_unlock</a>(v, res-&gt;<a class="code" href="structvirg__tablet__meta.html#a8287e9d36017a86bc3657de07cfbb47e" title="tablet id">id</a>);
                                pthread_exit(NULL);
                        }

                        <span class="comment">// if we haven&#39;t yet locked a tablet in this thread</span>
                        <span class="keywordflow">if</span>(tab != NULL)
                                <a class="code" href="group__tablet.html#ga8e6a3f46a4efe9347c8202acc032db69" title="Release a lock to a tablet.">virg_tablet_unlock</a>(v, tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a8287e9d36017a86bc3657de07cfbb47e" title="tablet id">id</a>);
                        <a class="code" href="group__database.html#ga78584f2bb7ca78e1cb87378929ce40f2" title="Advance a tablet pointer to the next tablet in its string of tablets.">virg_db_loadnext</a>(v, &amp;arg-&gt;tab);
                        <a class="code" href="group__tablet.html#gabd69b51cf1469c95d1574b1d53935391" title="Add a lock to a tablet.">virg_tablet_lock</a>(v, arg-&gt;tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a8287e9d36017a86bc3657de07cfbb47e" title="tablet id">id</a>);
                        tab = arg-&gt;tab;
                        arg-&gt;row = 0;
                }

                <span class="comment">// if we are just starting and no tablet has yet been assigned</span>
                <span class="keywordflow">if</span>(tab == NULL) {
                        <a class="code" href="group__tablet.html#gabd69b51cf1469c95d1574b1d53935391" title="Add a lock to a tablet.">virg_tablet_lock</a>(v, arg-&gt;tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a8287e9d36017a86bc3657de07cfbb47e" title="tablet id">id</a>);
                        tab = arg-&gt;tab;
                }

                <span class="comment">// set the local row cursor to the global row cursor</span>
                row = arg-&gt;row;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
                <span class="comment">// only process num_row rows, or as many as possible if num_rows is 0</span>
                <span class="keywordflow">if</span>(num_rows == 0)
                        last_row = tab-&gt;<a class="code" href="structvirg__tablet__meta.html#ac68b11acc7d264e16025e3017a3c671a" title="number of rows stored in this tablet">rows</a>;
                <span class="keywordflow">else</span>
                        last_row = <a class="code" href="virginian_8h.html#ac8c9f6fbeb9d60a07ec61b3f3430d48a" title="convenience macro to return the min of the two inputs">VIRG_MIN</a>(row + num_rows, tab-&gt;<a class="code" href="structvirg__tablet__meta.html#ac68b11acc7d264e16025e3017a3c671a" title="number of rows stored in this tablet">rows</a>);

<span class="preprocessor">#ifdef __MULTI</span>
<span class="preprocessor"></span>                <span class="comment">// update global row cursor</span>
                arg-&gt;row = last_row;
                pthread_mutex_unlock(&amp;arg-&gt;tab_lock);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
                <span class="comment">// while we haven&#39;t yet finished our row allocation</span>
                <span class="keywordflow">while</span>(row &lt; last_row) {
                        context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a> = vm-&gt;<a class="code" href="structvirg__vm.html#a58a76075e1de12dc9959753f38fb37bc" title="high-level program counter">pc</a>;

                        <span class="comment">// we want to process VIRG_CPU_SIMD at a time to cache effectively,</span>
                        <span class="comment">// but we might be at the end of the tablet and not have a full</span>
                        <span class="comment">// VIRG_CPU_SIMD rows left</span>
                        simd_rows = <a class="code" href="virginian_8h.html#ac8c9f6fbeb9d60a07ec61b3f3430d48a" title="convenience macro to return the min of the two inputs">VIRG_MIN</a>(<a class="code" href="virginian_8h.html#a6b039207848380e774147e035d3876c0" title="number of rows to process on the cpu in a block">VIRG_CPU_SIMD</a>, last_row - row);

                        <span class="comment">// set every row as still valid with a pc equal to the global pc</span>
                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++) {
                                context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] = vm-&gt;<a class="code" href="structvirg__vm.html#a58a76075e1de12dc9959753f38fb37bc" title="high-level program counter">pc</a>;
                                valid[i] = 1;
                        }
                        <span class="comment">// set every row between simd_rows and VIRG_CPU_SIMD to invalid</span>
                        <span class="keywordflow">for</span>( ; i &lt; <a class="code" href="virginian_8h.html#a6b039207848380e774147e035d3876c0" title="number of rows to process on the cpu in a block">VIRG_CPU_SIMD</a>; i++)
                                valid[i] = 0;


<span class="comment">//############################################################################</span>
<span class="comment">//############################################################################</span>

next:
        <span class="comment">// check that the row program counters make sense compared to the global pc</span>
        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++) {
                assert(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] &gt;= context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>);
        }
        <span class="comment">// jump to the next opcode using the jump table indexed by the opcode value</span>
        <span class="keywordflow">goto</span> *jump[vm-&gt;<a class="code" href="structvirg__vm.html#aa1232e0a814aa339153059d9f86320ba" title="opcode program">stmt</a>[context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>].op];

op_Converge:
        <span class="comment">// go to the next row block</span>
        row += <a class="code" href="virginian_8h.html#a6b039207848380e774147e035d3876c0" title="number of rows to process on the cpu in a block">VIRG_CPU_SIMD</a>;
        <span class="keywordflow">continue</span>;

op_Integer:
        <a class="code" href="virginia_8c.html#ae9c07c2544277918fd2ce691b2e8f91c">GETP1</a>
        <a class="code" href="virginia_8c.html#ac82147a944db7502131aac0d5952c951">GETP2</a>
        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++) {
                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] == context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                        context.reg[p1].i[i] = p2;
                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                }
        }
        context.<a class="code" href="structvirg__vm__simdcontext.html#a034886f5283b9d5118e6ace5117642c5" title="type stored in each register">type</a>[p1] = VIRG_INT;
        context.<a class="code" href="structvirg__vm__simdcontext.html#ac0799f5fb43cb6394ce29222d3506328" title="size in bytes of the variable stored in each registers">stride</a>[p1] = <span class="keyword">sizeof</span>(int);
        context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>++;
        <span class="keywordflow">goto</span> next;

op_Float:
        <a class="code" href="virginia_8c.html#ae9c07c2544277918fd2ce691b2e8f91c">GETP1</a>
        <a class="code" href="virginia_8c.html#ac82147a944db7502131aac0d5952c951">GETP2</a>
        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++) {
                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] == context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                        context.reg[p1].f[i] = vm-&gt;<a class="code" href="structvirg__vm.html#aa1232e0a814aa339153059d9f86320ba" title="opcode program">stmt</a>[context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>].p4.f;
                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                }
        }
        context.<a class="code" href="structvirg__vm__simdcontext.html#a034886f5283b9d5118e6ace5117642c5" title="type stored in each register">type</a>[p1] = VIRG_FLOAT;
        context.<a class="code" href="structvirg__vm__simdcontext.html#ac0799f5fb43cb6394ce29222d3506328" title="size in bytes of the variable stored in each registers">stride</a>[p1] = <span class="keyword">sizeof</span>(float);
        context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>++;
        <span class="keywordflow">goto</span> next;

op_Invalid:
        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++) {
                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] == context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                        valid[i] = 0;
                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                }
        }
        context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>++;
        <span class="keywordflow">goto</span> next;

op_Le:
        <a class="code" href="virginia_8c.html#a5928cf89ab28aa386703bbe4eb1090a4">REGCMP</a>(&lt;=);

op_Lt:
        <a class="code" href="virginia_8c.html#a5928cf89ab28aa386703bbe4eb1090a4">REGCMP</a>(&lt;);

op_Ge:
        <a class="code" href="virginia_8c.html#a5928cf89ab28aa386703bbe4eb1090a4">REGCMP</a>(&gt;=);

op_Gt:
        <a class="code" href="virginia_8c.html#a5928cf89ab28aa386703bbe4eb1090a4">REGCMP</a>(&gt;);

op_Eq:  <span class="comment">// col 1, col 2, jmp location, 0: invalid if jmp</span>
        <a class="code" href="virginia_8c.html#a5928cf89ab28aa386703bbe4eb1090a4">REGCMP</a>(==);

op_Neq:
        <a class="code" href="virginia_8c.html#a5928cf89ab28aa386703bbe4eb1090a4">REGCMP</a>(!=);

op_Column: <span class="comment">// dest reg, src col</span>
        <a class="code" href="virginia_8c.html#ae9c07c2544277918fd2ce691b2e8f91c">GETP1</a>
        <a class="code" href="virginia_8c.html#ac82147a944db7502131aac0d5952c951">GETP2</a>
        ptr1 = (<span class="keywordtype">char</span>*)tab + tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a7b2629d1c97658c8b7a89dff95a1d52b" title="relative ptr to the beginning of the fixed-column area">fixed_block</a> + tab-&gt;<a class="code" href="structvirg__tablet__meta.html#af46cdc848ccee989cf764abb07a9f29a" title="relative pointer from fixed_block indicating the beginning of the column">fixed_offset</a>[p2] + tab-&gt;<a class="code" href="structvirg__tablet__meta.html#af8affe76f89dd02d3f09a052982ae428" title="size in bytes of each of the fixed-size columns">fixed_stride</a>[p2] * row;

        <span class="comment">// copy column segment directly into the register struct</span>
        memcpy(&amp;context.reg[p1], ptr1, tab-&gt;<a class="code" href="structvirg__tablet__meta.html#af8affe76f89dd02d3f09a052982ae428" title="size in bytes of each of the fixed-size columns">fixed_stride</a>[p2] * simd_rows);
        context.<a class="code" href="structvirg__vm__simdcontext.html#a034886f5283b9d5118e6ace5117642c5" title="type stored in each register">type</a>[p1] = tab-&gt;<a class="code" href="structvirg__tablet__meta.html#acc96d33e2a323f0e0b90604e3524c626" title="types of the fixed-size columns">fixed_type</a>[p2];
        context.<a class="code" href="structvirg__vm__simdcontext.html#ac0799f5fb43cb6394ce29222d3506328" title="size in bytes of the variable stored in each registers">stride</a>[p1] = tab-&gt;<a class="code" href="structvirg__tablet__meta.html#af8affe76f89dd02d3f09a052982ae428" title="size in bytes of each of the fixed-size columns">fixed_stride</a>[p2];

        <span class="comment">// update row pcs</span>
        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] == context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>)
                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
        context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>++;
        <span class="keywordflow">goto</span> next;

op_Rowid: <span class="comment">// dest reg,       key ptr?</span>
        <a class="code" href="virginia_8c.html#ae9c07c2544277918fd2ce691b2e8f91c">GETP1</a>
        <a class="code" href="virginia_8c.html#ac82147a944db7502131aac0d5952c951">GETP2</a>
        ptr1 = (<span class="keywordtype">char</span>*)tab + tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a381166a5323a226a9cf70a527e9f7876" title="relative ptr to the beginning of the key column">key_block</a> + tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a16e649bf6f3217270c3fe84fe4d00114" title="stride of the variable type of the key column">key_stride</a> * row;

        <span class="comment">// copy column segment directly into the register struct</span>
        memcpy(&amp;context.reg[p1], ptr1, tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a16e649bf6f3217270c3fe84fe4d00114" title="stride of the variable type of the key column">key_stride</a> * simd_rows);
        context.<a class="code" href="structvirg__vm__simdcontext.html#a034886f5283b9d5118e6ace5117642c5" title="type stored in each register">type</a>[p1] = tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a21626738f2e3e000d376a912558130fa" title="variable type of the key column">key_type</a>;
        context.<a class="code" href="structvirg__vm__simdcontext.html#ac0799f5fb43cb6394ce29222d3506328" title="size in bytes of the variable stored in each registers">stride</a>[p1] = tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a16e649bf6f3217270c3fe84fe4d00114" title="stride of the variable type of the key column">key_stride</a>;

        <span class="comment">// update row pcs</span>
        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] == context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>)
                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
        context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>++;
        <span class="keywordflow">goto</span> next;

op_Result: <span class="comment">// start reg, num regs</span>

        total_valid = 0;
        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                <span class="keywordflow">if</span>(valid[i])
                        total_valid++;

<span class="preprocessor">#ifdef __MULTI</span>
<span class="preprocessor"></span><span class="comment">        /**</span>
<span class="comment">         * All threads share a result tablet and lock a mutex on it to get a block</span>
<span class="comment">         * on the tablet where they can place their result rows.</span>
<span class="comment">         */</span>
        pthread_mutex_lock(&amp;arg-&gt;res_lock);

        <span class="comment">// if the result tablet is full</span>
        <span class="keywordflow">if</span>(res-&gt;<a class="code" href="structvirg__tablet__meta.html#ac68b11acc7d264e16025e3017a3c671a" title="number of rows stored in this tablet">rows</a> + simd_rows &gt;= res-&gt;<a class="code" href="structvirg__tablet__meta.html#a785691ca2a53ec6a5d5c34bca74c882d" title="fixed-size rows that can be in this tablet without reorganizing columns">possible_rows</a>) {
                <span class="comment">// if the local result tablet is the global result tablet</span>
                <span class="keywordflow">if</span>(res == arg-&gt;res) {
                        <span class="comment">// unlock current tablet and allocate another one</span>
                        <a class="code" href="group__tablet.html#ga8e6a3f46a4efe9347c8202acc032db69" title="Release a lock to a tablet.">virg_tablet_unlock</a>(v, res-&gt;<a class="code" href="structvirg__tablet__meta.html#a8287e9d36017a86bc3657de07cfbb47e" title="tablet id">id</a>);
                        <a class="code" href="group__tablet.html#ga8e6a3f46a4efe9347c8202acc032db69" title="Release a lock to a tablet.">virg_tablet_unlock</a>(v, res-&gt;<a class="code" href="structvirg__tablet__meta.html#a8287e9d36017a86bc3657de07cfbb47e" title="tablet id">id</a>);
                        <a class="code" href="group__vm.html#gae7f94c15491cb88fd9c2325222a40b2c" title="Allocate and create a new result tablet or copy an existing tablet.">virg_vm_allocresult</a>(v, vm, &amp;arg-&gt;res, arg-&gt;res);
                        <a class="code" href="group__tablet.html#gabd69b51cf1469c95d1574b1d53935391" title="Add a lock to a tablet.">virg_tablet_lock</a>(v, arg-&gt;res-&gt;<a class="code" href="structvirg__tablet__meta.html#a8287e9d36017a86bc3657de07cfbb47e" title="tablet id">id</a>);
                }
                <span class="keywordflow">else</span> {
                        <span class="comment">// otherwise move to the current global result tablet</span>
                        <a class="code" href="group__tablet.html#ga8e6a3f46a4efe9347c8202acc032db69" title="Release a lock to a tablet.">virg_tablet_unlock</a>(v, res-&gt;<a class="code" href="structvirg__tablet__meta.html#a8287e9d36017a86bc3657de07cfbb47e" title="tablet id">id</a>);
                        <a class="code" href="group__tablet.html#gabd69b51cf1469c95d1574b1d53935391" title="Add a lock to a tablet.">virg_tablet_lock</a>(v, arg-&gt;res-&gt;<a class="code" href="structvirg__tablet__meta.html#a8287e9d36017a86bc3657de07cfbb47e" title="tablet id">id</a>);
                }
                res = arg-&gt;res;
        }

        <span class="comment">// allocate area</span>
        <span class="keywordtype">unsigned</span> write_row = res-&gt;<a class="code" href="structvirg__tablet__meta.html#ac68b11acc7d264e16025e3017a3c671a" title="number of rows stored in this tablet">rows</a>;
        res-&gt;<a class="code" href="structvirg__tablet__meta.html#ac68b11acc7d264e16025e3017a3c671a" title="number of rows stored in this tablet">rows</a> += total_valid;

        pthread_mutex_unlock(&amp;arg-&gt;res_lock);

<span class="preprocessor">#else</span>
<span class="preprocessor"></span>
        <span class="comment">// check if theres still room in the result tablet and allocate a new one if</span>
        <span class="comment">// not</span>
        <span class="keywordflow">if</span>(res-&gt;<a class="code" href="structvirg__tablet__meta.html#ac68b11acc7d264e16025e3017a3c671a" title="number of rows stored in this tablet">rows</a> + simd_rows &gt;= res-&gt;<a class="code" href="structvirg__tablet__meta.html#a785691ca2a53ec6a5d5c34bca74c882d" title="fixed-size rows that can be in this tablet without reorganizing columns">possible_rows</a> - 300) {
                <a class="code" href="group__tablet.html#ga8e6a3f46a4efe9347c8202acc032db69" title="Release a lock to a tablet.">virg_tablet_unlock</a>(v, res-&gt;<a class="code" href="structvirg__tablet__meta.html#a8287e9d36017a86bc3657de07cfbb47e" title="tablet id">id</a>);
                <a class="code" href="group__tablet.html#ga8e6a3f46a4efe9347c8202acc032db69" title="Release a lock to a tablet.">virg_tablet_unlock</a>(v, res-&gt;<a class="code" href="structvirg__tablet__meta.html#a8287e9d36017a86bc3657de07cfbb47e" title="tablet id">id</a>);
                <a class="code" href="group__vm.html#gae7f94c15491cb88fd9c2325222a40b2c" title="Allocate and create a new result tablet or copy an existing tablet.">virg_vm_allocresult</a>(v, vm, &amp;res, res);
                res_[0] = res;
                <a class="code" href="group__tablet.html#gabd69b51cf1469c95d1574b1d53935391" title="Add a lock to a tablet.">virg_tablet_lock</a>(v, res-&gt;<a class="code" href="structvirg__tablet__meta.html#a8287e9d36017a86bc3657de07cfbb47e" title="tablet id">id</a>);
        }

        <span class="keywordtype">unsigned</span> write_row = res-&gt;<a class="code" href="structvirg__tablet__meta.html#ac68b11acc7d264e16025e3017a3c671a" title="number of rows stored in this tablet">rows</a>;
        res-&gt;<a class="code" href="structvirg__tablet__meta.html#ac68b11acc7d264e16025e3017a3c671a" title="number of rows stored in this tablet">rows</a> += total_valid;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        <span class="comment"></span>
<span class="comment">        /**</span>
<span class="comment">         * Outputting result rows is done through memcpy operations, and we make an</span>
<span class="comment">         * effort to minimize the number of these calls. Thus, for every register</span>
<span class="comment">         * being output, we loop over every one of the SIMD rows (which are adjacent</span>
<span class="comment">         * in memory) and lazily perform a copy only when we encounter a row that</span>
<span class="comment">         * will not be output to the result block.</span>
<span class="comment">         */</span>
        <span class="keywordtype">unsigned</span> block_start = 0;
        <a class="code" href="virginia_8c.html#ae9c07c2544277918fd2ce691b2e8f91c">GETP1</a>
        <a class="code" href="virginia_8c.html#ac82147a944db7502131aac0d5952c951">GETP2</a>

        <span class="keywordtype">unsigned</span> write_start = write_row;

        <span class="comment">// for all the registers in the op</span>
        <span class="keywordflow">for</span>(j = p1; j &lt; p1 + p2; j++) {
                <span class="keywordtype">unsigned</span> stride = context.<a class="code" href="structvirg__vm__simdcontext.html#ac0799f5fb43cb6394ce29222d3506328" title="size in bytes of the variable stored in each registers">stride</a>[j];
                <span class="keywordtype">unsigned</span> block_size = 0;
                write_row = write_start;

                <span class="comment">// for each valid row in simd width</span>
                <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++) {
                        <span class="comment">// if this is a row we want to output</span>
                        <span class="keywordflow">if</span>(valid[i]) {
                                <span class="comment">// increase the size of the block that we will eventually copy</span>
                                <span class="keywordflow">if</span>(block_size == 0)
                                        block_start = i;
                                block_size++;
                        }
                        <span class="comment">// otherwise copy everything in the block up to this point, except</span>
                        <span class="comment">// if the block is of size 0</span>
                        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(block_size &gt; 0) {
                                ptr1 = (<span class="keywordtype">char</span>*)res + res-&gt;<a class="code" href="structvirg__tablet__meta.html#a7b2629d1c97658c8b7a89dff95a1d52b" title="relative ptr to the beginning of the fixed-column area">fixed_block</a> + res-&gt;<a class="code" href="structvirg__tablet__meta.html#af46cdc848ccee989cf764abb07a9f29a" title="relative pointer from fixed_block indicating the beginning of the column">fixed_offset</a>[j - p1] + stride * write_row;
                                ptr2 = (<span class="keywordtype">char</span>*)&amp;context.reg[j] + stride * block_start;
                                memcpy(ptr1, ptr2, block_size * stride);
                                write_row += block_size;
                                block_size = 0;
                        }
                }

                <span class="comment">// finish off by copying the last block</span>
                ptr1 = (<span class="keywordtype">char</span>*)res + res-&gt;<a class="code" href="structvirg__tablet__meta.html#a7b2629d1c97658c8b7a89dff95a1d52b" title="relative ptr to the beginning of the fixed-column area">fixed_block</a> + res-&gt;<a class="code" href="structvirg__tablet__meta.html#af46cdc848ccee989cf764abb07a9f29a" title="relative pointer from fixed_block indicating the beginning of the column">fixed_offset</a>[j - p1] + stride * write_row;
                ptr2 = (<span class="keywordtype">char</span>*)&amp;context.reg[j] + stride * block_start;
                memcpy(ptr1, ptr2, block_size * stride);
        }

        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
        context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>++;
        <span class="keywordflow">goto</span> next;

op_Add:
        <a class="code" href="virginia_8c.html#a297d507b2e5432fbe16ea9bd8cceed7b">MATHOP</a>(+);

op_Sub:
        <a class="code" href="virginia_8c.html#a297d507b2e5432fbe16ea9bd8cceed7b">MATHOP</a>(-);

op_Mul:
        <a class="code" href="virginia_8c.html#a297d507b2e5432fbe16ea9bd8cceed7b">MATHOP</a>(*);

op_Div:
        <a class="code" href="virginia_8c.html#a297d507b2e5432fbe16ea9bd8cceed7b">MATHOP</a>(/);

op_And:
        <a class="code" href="virginia_8c.html#a5928cf89ab28aa386703bbe4eb1090a4">REGCMP</a>(&amp;&amp;);

op_Or:
        <a class="code" href="virginia_8c.html#a5928cf89ab28aa386703bbe4eb1090a4">REGCMP</a>(||);

op_Not:
{
        <a class="code" href="virginia_8c.html#ae9c07c2544277918fd2ce691b2e8f91c">GETP1</a>
        <a class="code" href="virginia_8c.html#a84944dc56b42abd52e2b118ea5988f78">GETP3</a>

        <span class="keywordflow">switch</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a034886f5283b9d5118e6ace5117642c5" title="type stored in each register">type</a>[p1]) {
                <span class="keywordflow">case</span> VIRG_INT:
                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++) {
                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] == context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                        <span class="keywordtype">int</span> x = context.reg[p1].i[i];
                                        <span class="keywordflow">if</span>(!x) {
                                                <span class="keywordflow">if</span>(valid[i])
                                                        valid[i] = vm-&gt;<a class="code" href="structvirg__vm.html#aa1232e0a814aa339153059d9f86320ba" title="opcode program">stmt</a>[context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>].p4.i;
                                                context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] = p3;
                                        }
                                        <span class="keywordflow">else</span>
                                                context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                }
                        }
                        <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> VIRG_FLOAT:
                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++) {
                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] == context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                        <span class="keywordtype">float</span> x = context.reg[p1].f[i];
                                        <span class="keywordflow">if</span>(!x) {
                                                <span class="keywordflow">if</span>(valid[i])
                                                        valid[i] = vm-&gt;<a class="code" href="structvirg__vm.html#aa1232e0a814aa339153059d9f86320ba" title="opcode program">stmt</a>[context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>].p4.i;
                                                context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] = p3;
                                        }
                                        <span class="keywordflow">else</span>
                                                context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                }
                        }
                        <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> VIRG_INT64:
                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++) {
                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] == context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                        <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> x = context.reg[p1].li[i];
                                        <span class="keywordflow">if</span>(!x) {
                                                <span class="keywordflow">if</span>(valid[i])
                                                        valid[i] = vm-&gt;<a class="code" href="structvirg__vm.html#aa1232e0a814aa339153059d9f86320ba" title="opcode program">stmt</a>[context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>].p4.i;
                                                context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] = p3;
                                        }
                                        <span class="keywordflow">else</span>
                                                context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                }
                        }
                        <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> VIRG_DOUBLE:
                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++) {
                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] == context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                        <span class="keywordtype">double</span> x = context.reg[p1].d[i];
                                        <span class="keywordflow">if</span>(!x) {
                                                <span class="keywordflow">if</span>(valid[i])
                                                        valid[i] = vm-&gt;<a class="code" href="structvirg__vm.html#aa1232e0a814aa339153059d9f86320ba" title="opcode program">stmt</a>[context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>].p4.i;
                                                context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] = p3;
                                        }
                                        <span class="keywordflow">else</span>
                                                context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                }
                        }
                        <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> VIRG_CHAR:
                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++) {
                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] == context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                        <span class="keywordtype">char</span> x = context.reg[p1].c[i];
                                        <span class="keywordflow">if</span>(!x) {
                                                <span class="keywordflow">if</span>(valid[i])
                                                        valid[i] = vm-&gt;<a class="code" href="structvirg__vm.html#aa1232e0a814aa339153059d9f86320ba" title="opcode program">stmt</a>[context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>].p4.i;
                                                context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] = p3;
                                        }
                                        <span class="keywordflow">else</span>
                                                context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                }
                        }
                        <span class="keywordflow">break</span>;
                <span class="keywordflow">default</span>:
                        assert(0);
                        <span class="keywordflow">break</span>;
        }
        context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>++;
        <span class="keywordflow">goto</span> next;
}

op_Cast: <span class="comment">// dest type, reg</span>
        <span class="keywordflow">switch</span>(p1) {
                <span class="keywordflow">case</span> VIRG_INT:
                        <span class="keywordflow">switch</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a034886f5283b9d5118e6ace5117642c5" title="type stored in each register">type</a>[p2]) {
                                <span class="keywordflow">case</span> VIRG_FLOAT:
                                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] &lt;= context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                                        context.reg[p2].i[i] = (int) context.reg[p2].f[i];
                                                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                                }
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">case</span> VIRG_INT64:
                                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] &lt;= context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                                        context.reg[p2].i[i] = (int) context.reg[p2].li[i];
                                                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                                }
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">case</span> VIRG_DOUBLE:
                                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] &lt;= context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                                        context.reg[p2].i[i] = (int) context.reg[p2].d[i];
                                                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                                }
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">case</span> VIRG_CHAR:
                                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] &lt;= context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                                        context.reg[p2].i[i] = (int) context.reg[p2].c[i];
                                                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                                }
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">default</span>:
                                        <span class="keywordflow">break</span>;
                        }
                        context.<a class="code" href="structvirg__vm__simdcontext.html#ac0799f5fb43cb6394ce29222d3506328" title="size in bytes of the variable stored in each registers">stride</a>[p2] = <span class="keyword">sizeof</span>(int);
                        <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> VIRG_FLOAT:
                        <span class="keywordflow">switch</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a034886f5283b9d5118e6ace5117642c5" title="type stored in each register">type</a>[p2]) {
                                <span class="keywordflow">case</span> VIRG_INT:
                                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] &lt;= context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                                        context.reg[p2].f[i] = (float) context.reg[p2].i[i];
                                                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                                }
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">case</span> VIRG_INT64:
                                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] &lt;= context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                                        context.reg[p2].f[i] = (float) context.reg[p2].li[i];
                                                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                                }
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">case</span> VIRG_DOUBLE:
                                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] &lt;= context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                                        context.reg[p2].f[i] = (float) context.reg[p2].d[i];
                                                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                                }
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">case</span> VIRG_CHAR:
                                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] &lt;= context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                                        context.reg[p2].f[i] = (float) context.reg[p2].c[i];
                                                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                                }
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">default</span>:
                                        <span class="keywordflow">break</span>;
                        }
                        context.<a class="code" href="structvirg__vm__simdcontext.html#ac0799f5fb43cb6394ce29222d3506328" title="size in bytes of the variable stored in each registers">stride</a>[p2] = <span class="keyword">sizeof</span>(float);
                        <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> VIRG_INT64:
                        <span class="keywordflow">switch</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a034886f5283b9d5118e6ace5117642c5" title="type stored in each register">type</a>[p2]) {
                                <span class="keywordflow">case</span> VIRG_INT:
                                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] &lt;= context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                                        context.reg[p2].li[i] = (<span class="keywordtype">long</span> <span class="keywordtype">long</span> int) context.reg[p2].i[i];
                                                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                                }
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">case</span> VIRG_FLOAT:
                                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] &lt;= context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                                        context.reg[p2].li[i] = (<span class="keywordtype">long</span> <span class="keywordtype">long</span> int) context.reg[p2].f[i];
                                                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                                }
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">case</span> VIRG_DOUBLE:
                                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] &lt;= context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                                        context.reg[p2].li[i] = (<span class="keywordtype">long</span> <span class="keywordtype">long</span> int) context.reg[p2].d[i];
                                                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                                }
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">case</span> VIRG_CHAR:
                                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] &lt;= context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                                        context.reg[p2].li[i] = (<span class="keywordtype">long</span> <span class="keywordtype">long</span> int) context.reg[p2].c[i];
                                                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                                }
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">default</span>:
                                        <span class="keywordflow">break</span>;
                        }
                        context.<a class="code" href="structvirg__vm__simdcontext.html#ac0799f5fb43cb6394ce29222d3506328" title="size in bytes of the variable stored in each registers">stride</a>[p2] = <span class="keyword">sizeof</span>(<span class="keywordtype">long</span> <span class="keywordtype">long</span> int);
                        <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> VIRG_DOUBLE:
                        <span class="keywordflow">switch</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a034886f5283b9d5118e6ace5117642c5" title="type stored in each register">type</a>[p2]) {
                                <span class="keywordflow">case</span> VIRG_INT:
                                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] &lt;= context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                                        context.reg[p2].d[i] = (double) context.reg[p2].i[i];
                                                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                                }
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">case</span> VIRG_FLOAT:
                                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] &lt;= context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                                        context.reg[p2].d[i] = (double) context.reg[p2].f[i];
                                                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                                }
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">case</span> VIRG_INT64:
                                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] &lt;= context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                                        context.reg[p2].d[i] = (double) context.reg[p2].li[i];
                                                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                                }
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">case</span> VIRG_CHAR:
                                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] &lt;= context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                                        context.reg[p2].d[i] = (double) context.reg[p2].c[i];
                                                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                                }
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">default</span>:
                                        <span class="keywordflow">break</span>;
                        }
                        context.<a class="code" href="structvirg__vm__simdcontext.html#ac0799f5fb43cb6394ce29222d3506328" title="size in bytes of the variable stored in each registers">stride</a>[p2] = <span class="keyword">sizeof</span>(double);
                        <span class="keywordflow">break</span>;
                <span class="keywordflow">case</span> VIRG_CHAR:
                        <span class="keywordflow">switch</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a034886f5283b9d5118e6ace5117642c5" title="type stored in each register">type</a>[p2]) {
                                <span class="keywordflow">case</span> VIRG_INT:
                                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] &lt;= context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                                        context.reg[p2].c[i] = (char) context.reg[p2].i[i];
                                                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                                }
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">case</span> VIRG_FLOAT:
                                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] &lt;= context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                                        context.reg[p2].c[i] = (char) context.reg[p2].f[i];
                                                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                                }
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">case</span> VIRG_INT64:
                                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] &lt;= context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                                        context.reg[p2].c[i] = (char) context.reg[p2].li[i];
                                                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                                }
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">case</span> VIRG_DOUBLE:
                                        <span class="keywordflow">for</span>(i = 0; i &lt; simd_rows; i++)
                                                <span class="keywordflow">if</span>(context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i] &lt;= context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>) {
                                                        context.reg[p2].c[i] = (char) context.reg[p2].c[i];
                                                        context.<a class="code" href="structvirg__vm__simdcontext.html#a9422c8e06f212c5c20c4834d593f7d64" title="program counter for individual rows in the block">row_pc</a>[i]++;
                                                }
                                        <span class="keywordflow">break</span>;
                                <span class="keywordflow">default</span>:
                                        <span class="keywordflow">break</span>;
                        }
                        context.<a class="code" href="structvirg__vm__simdcontext.html#ac0799f5fb43cb6394ce29222d3506328" title="size in bytes of the variable stored in each registers">stride</a>[p2] = <span class="keyword">sizeof</span>(char);
                        <span class="keywordflow">break</span>;
        }
        context.<a class="code" href="structvirg__vm__simdcontext.html#a034886f5283b9d5118e6ace5117642c5" title="type stored in each register">type</a>[p2] = (<a class="code" href="virginian_8h.html#a5edb977d9e195d5df43f1757f311292b" title="enumeration of all variable types used by the database">virg_t</a>)p1;
        context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>++;
        <span class="keywordflow">goto</span> next;

<span class="comment">// op for an incorrect jump location in the jump table</span>
NOP:
        fprintf(stderr, <span class="stringliteral">&quot;Invalid OP  %u\n&quot;</span>, vm-&gt;<a class="code" href="structvirg__vm.html#aa1232e0a814aa339153059d9f86320ba" title="opcode program">stmt</a>[context.<a class="code" href="structvirg__vm__simdcontext.html#a1aeef8a6559545c81e502985f63c28ee" title="global program counter">pc</a>].op);
<span class="preprocessor">#ifdef __SINGLE</span>
<span class="preprocessor"></span>        <span class="keywordflow">return</span>;
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>        pthread_exit(NULL);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>

<span class="comment">//############################################################################</span>
<span class="comment">//############################################################################</span>

                } <span class="comment">// while(row &lt; last_row)</span>

<span class="comment">// if this is single threaded, we break, otherwise we continue the loop</span>
<span class="comment">// indefinitely and check if we are done processing data in its middle</span>
<span class="preprocessor">#ifdef __SINGLE</span>
<span class="preprocessor"></span>                <span class="keywordflow">break</span>;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
        } <span class="comment">// while(1)</span>


        <span class="comment">// single threaded version unlocks it data and result tablets to finish</span>
        <a class="code" href="group__tablet.html#ga8e6a3f46a4efe9347c8202acc032db69" title="Release a lock to a tablet.">virg_tablet_unlock</a>(v, tab-&gt;<a class="code" href="structvirg__tablet__meta.html#a8287e9d36017a86bc3657de07cfbb47e" title="tablet id">id</a>);
        <a class="code" href="group__tablet.html#ga8e6a3f46a4efe9347c8202acc032db69" title="Release a lock to a tablet.">virg_tablet_unlock</a>(v, res-&gt;<a class="code" href="structvirg__tablet__meta.html#a8287e9d36017a86bc3657de07cfbb47e" title="tablet id">id</a>);
}
</pre></div>
</div>
</div>
<a class="anchor" id="ga5eaa0064c9e2b63ad19d7e3ea95da9c0"></a><!-- doxytag: member="virginia.c::virginia_single" ref="ga5eaa0064c9e2b63ad19d7e3ea95da9c0" args="(virginian *v, virg_vm *vm, virg_tablet_meta *tab, virg_tablet_meta **res_, unsigned row, unsigned num_rows)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void virginia_single </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvirginian.html">virginian</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirg__vm.html">virg_vm</a> *&#160;</td>
          <td class="paramname"><em>vm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirg__tablet__meta.html">virg_tablet_meta</a> *&#160;</td>
          <td class="paramname"><em>tab</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvirg__tablet__meta.html">virg_tablet_meta</a> **&#160;</td>
          <td class="paramname"><em>res_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>num_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Execute the data-parallel portion of an opcode program on a single core. </p>
<p>This function executes the opcodes inbetween Parallel and Converge. The single core version is assigned a tablet, and executes the opcodes on up to num_rows in that tablet, or all if num_rows is 0.</p>
<p>Like <a class="el" href="group__vm.html#ga7112813a421bcf264ceae71555f18dce" title="Execute the virtual machine using its stored statement.">virg_vm_execute()</a>, <a class="el" href="group__vm.html#ga5eaa0064c9e2b63ad19d7e3ea95da9c0" title="Execute the data-parallel portion of an opcode program on a single core.">virginia_single()</a> and <a class="el" href="group__vm.html#gac8a59abde2076fa5dad105b0ec11cf5f" title="Execute the data-parallel portion of an opcode program on multiple cores.">virginia_multi()</a> use a jump table rather than a switch to access the code for each opcode. This is accomplished with an array of label addresses, which is accessed with the value of each opcode, then jumped to with a goto.</p>
<p>The CPU virtual machine is written with tight inner loops to process blocks of rows at the same time, which we'll call a SIMD block. Since both cells in a column, and cells in a SIMD virtual machine register are stored adjacent to each other, this allows for efficient cache locality and direct memcpy operations.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Pointer to the state struct of the database system </td></tr>
    <tr><td class="paramname">vm</td><td>Pointer to the context struct of the virtual machine </td></tr>
    <tr><td class="paramname">tab</td><td>Pointer to the current data tablet to process </td></tr>
    <tr><td class="paramname">res</td><td>Pointer to the pointer to the current result tablet </td></tr>
    <tr><td class="paramname">row</td><td>The row to begin processing the current data tablet </td></tr>
    <tr><td class="paramname">num_rows</td><td>The number of rows to process in this function, 0 for as many as possible </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>VIRG_SUCCESS or VIRG_FAIL depending on errors during the function call </dd></dl>

</div>
</div>
</div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Feb 15 2012 01:21:46 for Virginian by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
